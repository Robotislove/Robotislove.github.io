---
layout: post
title: ARM Cortex-M学习笔记
date: 2023-10-1
author: lau
tags: [DL, Note]
comments: true
toc: true
pinned: false
---

ARM Cortex-M学习笔记。

<!-- more -->

首先是ARM Cortex-M的学习资源汇总，这里包含书籍和学习参考资源。

## 嵌入式学习资源汇总
### 官方资源和手册参考
#### 中文参考手册

| 类别                                   | 资源                                                                     | 版本                                                   | 短评                                                          
|--------------------------------------|------------------------------------------------------------------------|------------------------------------------------------|--------------------------------------------------------------|
| 官方汇总                                 | cortex-m-resources                                                     | /                                                    | ARM公司专家Joseph Yiu收集整理的所有对开发者有用的官方Cortex-M资料链接（也包含极少资源链接）  |
| 概念科普                                 | Cortex-M ARM官方主页                                                       | /                                                    | 最权威的Cortex-M资源来源，最新的Cortex-M技术应该从这里去找                        
| ARM_Cortex-M维基百科                     | /                                                                      | 对于技术名词的解释，Wikipedia是非常专业的，wiki最后还给出Cortex-M相关资源下载链接  | /                                                        
| ARM Cortex-M for Beginners           | /                                                                      | /                                                    | /                                                            |   
| ARM Cortex-M处理器入门                    | v3                                                                     | /                                                    | /                                                           
| 2017 March                           | ARM公司专家Joseph Yiu写的白皮书，可以说一篇文章让你看懂Cortex-M0/M0+/M1/M3/M4/M7/M23/M33差异  | /                                                    | /                                            | 
| 内核手册                                 | ARMv6/v7/v8-M Architecture Reference Manual                            | /                                                    | ARM Cortex-M内核架构参考手册，还有比这个更权威的资料么？              
| Cortex-Mx Technical Reference Manual | /                                                                      | ARM Cortex-M处理器技术参考手册，还有比这个更权威的资料么？                  | /                                     |  
| Cortex-Mx Devices Generic User Guide | /                                                                      | ARM Cortex-M芯片使用指南，还有比这个更权威的资料么？                     | /                                       |  

#### 英文参考手册
Arm Helium Technology M-Profile Vector Extension (MVE) for Arm Cortex-M Processor (reference book)
Available here: https://www.arm.com/resources/education/books/mve-reference-book。
https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/cortex-m-resources。
### 书籍推荐
1. ARM Cortex-M0 全可编程SoC原理及实现
2. 嵌入式微控制器与处理器设计
3. Cortex-M4，M3，M0权威指南（中英文版）

## 嵌入式C语言汇总
### 嵌入式C常见用法
#### 关键词

关键字是C语言中具有特殊功能的保留标示符，按照功能可分为

1). 数据类型(常用char, short, int, long, unsigned, float, double)

2). 运算和表达式( =, +, -, *, while, do-while, if, goto, switch-case)

3). 数据存储(auto， static， extern，const， register，volatile，restricted)，

4). 结构(struct, enum, union,typedef),

5). 位操作和逻辑运算(<<, >>, &, |, ~，^, &&)，

6). 预处理(#define, #include, #error，#if...#elif...#else...#endif等)，

7). 平台扩展关键字(__asm, __inline，__syscall)

这些关键字共同构成了嵌入式平台的C语法。

嵌入式的应用从逻辑上可以抽象为三个部分：

1). 数据的输入(如传感器，信号，接口输入),

2). 数据的处理(如协议的解码和封包，AD采样值的转换等)

3). 数据的输出(GUI的显示，输出的引脚状态，DA的输出控制电压，PWM波的占空比等)，
对于数据的管理就贯穿着整个嵌入式应用的开发，它包含数据类型，存储空间管理，位和逻辑操作，以及数据结构，C语言从语法上支撑上述功能的实现，并提供相应的优化机制，以应对嵌入式下更受限的资源环境。

#### 数据类型

C语言支持常用的字符型，整型，浮点型变量，有些编译器如keil还扩展支持bit(位)和sfr(寄存器)等数据类型来满足特殊的地址操作。C语言只规定了每种基本数据类型的最小取值范围，因此在不同芯片平台上相同类型可能占用不同长度的存储空间，这就需要在代码实现时考虑后续移植的兼容性，而C语言提供的typedef就是用于处理这种情况的关键字，在大部分支持跨平台的软件项目中被采用，典型的如下:

```c
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
......
typedef signed int int32_t;
```

既然不同平台的基本数据宽度不同，那么如何确定当前平台的基础数据类型如int的宽度，这就需要C语言提供的接口sizeof，实现如下。

```c
printf("int size:%d, short size:%d, char size:%d\n", sizeof(int), sizeof(char), sizeof(short));
```

这里还有重要的知识点，就是指针的宽度，如
```c
char *p；
printf("point p size:%d\n", sizeof(p));
```
其实这就和芯片的可寻址宽度有关，如32位MCU的宽度就是4，64位MCU的宽度就是8，在有些时候这也是查看MCU位宽比较简单的方式。

#### 内存管理和存储架构

C语言允许程序变量在定义时就确定内存地址，通过作用域，以及关键字extern，static，实现了精细的处理机制，按照在硬件的区域不同，内存分配有三种方式(节选自C++高质量编程)：

1). 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。

2). 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中 ，效率很高，但是分配的内存容量有限。

3). 从堆上分配，亦称动态内存分配。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但同时遇到问题也最多。
这里先看个简单的C语言实例。

```c
//main.c#include <stdio.h>#include <stdlib.h>

static int st_val;                   //静态全局变量 -- 静态存储区
int ex_val;                           //全局变量 -- 静态存储区int main(void)
{
   int a = 0;                         //局部变量 -- 栈上申请
   int *ptr = NULL;                   //指针变量
   static int local_st_val = 0;       //静态变量
   local_st_val += 1;
   a = local_st_val;
   ptr = (int *)malloc(sizeof(int)); //从堆上申请空间
   if(ptr != NULL)
   {      
    printf("*p value:%d", *ptr);
    free(ptr);      
    ptr = NULL;      
    //free后需要将ptr置空，否则会导致后续ptr的校验失效，出现野指针   
    }            
}
```

C语言的作用域不仅描述了标识符的可访问的区域，其实也规定了变量的存储区域，在文件作用域的变量st_val和ex_val被分配到静态存储区，其中static关键字主要限定变量能否被其它文件访问，而代码块作用域中的变量a, ptr和local_st_val则要根据类型的不同，分配到不同的区域，其中a是局部变量，被分配到栈中，ptr作为指针，由malloc分配空间，因此定义在堆中，而local_st_val则被关键字限定，表示分配到静态存储区，这里就涉及到重要知识点，static在文件作用域和代码块作用域的意义是不同的：在文件作用域用于限定函数和变量的外部链接性(能否被其它文件访问), 在代码块作用域则用于将变量分配到静态存储区。

对于C语言，如果理解上述知识对于内存管理基本就足够，但对于嵌入式C来说，定义一个变量，它不一定在内存(SRAM)中，也有可能在FLASH空间，或直接由寄存器存储(register定义变量或者高优化等级下的部分局部变量)，如定义为const的全局变量定义在FLASH中，定义为register的局部变量会被优化到直接放在通用寄存器中，在优化运行速度，或者存储受限时，理解这部分知识对于代码的维护就很有意义。此外，嵌入式C语言的编译器中会扩展内存管理机制，如支持分散加载机制和__attribute__((section("用户定义区域")))，允许指定变量存储在特殊的区域如(SDRAM, SQI FLASH), 这强化了对内存的管理，以适应复杂的应用环境场景和需求。

```c
LD_ROM 0x00800000 0x10000 { ;load region size_region
    EX_ROM 0x00800000 0x10000 { ;load address = execution address
  *.o (RESET, +First)
  *(InRoot$$Sections)
  .ANY (+RO)
  }
  EX_RAM 0x20000000 0xC000 { ;rw Data
    .ANY (+RW +ZI)
  }
  EX_RAM1 0x2000C000 0x2000 {
    .ANY(MySection)
   }
  EX_RAM2 0x40000000 0x20000{
    .ANY(Sdram)
  }
}

int a[10] __attribute__((section("Mysection")));
int b[100] __attribute__((section("Sdram")));
```

采用这种方式，我们就可以将变量指定到需要的区域，这在某些情况下必须的，如做GUI或者网页时因为要存储大量图片和文档，内部FLASH空间可能不足，这时就可以将变量声明到外部区域，另外内存中某些部分的数据比较重要，为了避免被其它内容覆盖，可能需要单独划分SRAM区域，避免被误修改导致致命性的错误，这些经验在实际的产品开发中是常用且重要，不过因为篇幅原因，这里只简略的提供例子，如果工作中遇到这种需求，建议详细去了解下。

至于堆的使用，对于嵌入式Linux来说，使用起来和标准C语言一致，注意malloc后的检查，释放后记得置空，避免"野指针“，不过对于资源受限的单片机来说，使用malloc的场景一般较少，如果需要频繁申请内存块的场景，都会构建基于静态存储区和内存块分割的一套内存管理机制，一方面效率会更高(用固定大小的块提前分割，在使用时直接查找编号处理)，另一方面对于内存块的使用可控，可以有效避免内存碎片的问题，常见的如RTOS和网络LWIP都是采用这种机制，我个人习惯也采用这种方式，所以关于堆的细节不在描述，如果希望了解，可以参考<C Primer Plus>中关于存储相关的说明。

#### 指针和数组

数组和指针往往是引起程序bug的主要原因，如数组越界，指针越界，非法地址访问，非对齐访问，这些问题背后往往都有指针和数组的影子，因此理解和掌握指针和数组，是成为合格C语言开发者的必经之路。

数组是由相同类型元素构成，当它被声明时，编译器就根据内部元素的特性在内存中分配一段空间，另外C语言也提供多维数组，以应对特殊场景的需求，而指针则是提供使用地址的符号方法，只有指向具体的地址才有意义，C语言的指针具有最大的灵活性，在被访问前，可以指向任何地址，这大大方便了对硬件的操作，但同时也对开发者有了更高的要求。参考如下代码。

```c
int main(void)
{
  char cval[] = "hello";
  int i;
  int ival[] = {1, 2, 3, 4};
  int arr_val[][2] = {{1, 2}, {3, 4}};
  const char *pconst = "hello";
  char *p;
  int *pi;
  int *pa;
  int **par;

  p = cval;
  p++;            //addr增加1
  pi = ival;
  pi+=1;          //addr增加4
  pa = arr_val[0];
  pa+=1;          //addr增加4
  par = arr_val;
  par++;         //addr增加8
  for(i=0; i<sizeof(cval); i++)
  {
      printf("%d ", cval[i]);
  }
  printf("\n");
  printf("pconst:%s\n", pconst);
  printf("addr:%d, %d\n", cval, p);
  printf("addr:%d, %d\n", icval, pi);
  printf("addr:%d, %d\n", arr_val, pa);
  printf("addr:%d, %d\n", arr_val, par);
}

/* PC端64位系统下运行结果
0x68 0x65 0x6c 0x6c 0x6f 0x0
pconst:hello
addr:6421994, 6421995
addr:6421968, 6421972
addr:6421936, 6421940
addr:6421936, 6421944 */
```

对于数组来说，一般从0开始获取值，以length-1作为结束，通过[0, length)半开半闭区间访问，这一般不会出问题，但是某些时候，我们需要倒着读取数组时，有可能错误的将length作为起始点，从而导致访问越界，另外在操作数组时，有时为了节省空间，将访问的下标变量i定义为unsigned char类型，而C语言中unsigned char类型的范围是0~255，如果数组较大，会导致数组超过时无法截止，从而陷入死循环，这种在最初代码构建时很容易避免，但后期如果更改需求，在加大数组后，在使用数组的其它地方都会有隐患，需要特别注意。

在前面提到过，指针占有的空间与芯片的寻址宽度有关，32位平台为4字节，64位为8字节，而指针的加减运算中的长度又与它的类型相关，如char类型为1，int类型为4，如果你仔细观察上面的代码就会发现par的值增加了8，这是因为指向指针的指针，对应的变量是指针，也就是长度就是指针类型的长度，在64位平台下为8，如果在32位平台则为4，这些知识理解起来并不困难，但是这些特性在工程运用中稍有不慎，就会埋下不易察觉的问题。另外指针还支持强制转换，这在某些情况下相当有用，参考如下代码：
```c
#include <stdio.h>

typedef struct
{
  int b;
  int a;
}STRUCT_VAL;
static __align(4) char arr[8] = {0x12, 0x23, 0x34, 0x45, 0x56, 0x12, 0x24, 0x53};
int main(void)
{
    STRUCT_VAL *pval;
    int *ptr;
    pval = (STRUCT_VAL *)arr;
    ptr = (int *)&arr[4];
    printf("val:%d, %d", pval->a, pval->b);
    printf("val:%d,", *ptr);
}
//0x45342312 0x53241256
//0x53241256
```

基于指针的强制转换，在协议解析，数据存储管理中高效快捷的解决了数据解析的问题，但是在处理过程中涉及的数据对齐，大小端，是常见且十分易错的问题，如上面arr字符数组，通过__align(4)强制定义为4字节对齐是必要的，这里可以保证后续转换成int指针访问时，不会触发非对齐访问异常，如果没有强制定义，char默认是1字节对齐的，当然这并不就是一定触发异常(由整个内存的布局决定arr的地址，也与实际使用的空间是否支持非对齐访问有关，如部分SDRAM使用非对齐访问时，会触发异常), 这就导致可能增减其它变量，就可能触发这种异常，而出异常的地方往往和添加的变量毫无关系，而且代码在某些平台运行正常，切换平台后触发异常，这种隐蔽的现象是嵌入式中很难查找解决的问题。另外，C语言指针还有特殊的用法就是通过强制转换给特定的物理地址访问，通过函数指针实现回调，如下：

```c
#include <stdio.h>

typedef int (*pfunc)(int, int);
int func_add(int a, int b){
 return a+b;
}
int main(void)
{
    pfunc *func_ptr;
    *（volatile uint32_t *）0x20001000 = 0x01a23131;
    func_ptr = func_add;
    printf("%d\n", func_ptr(1, 2));
}
```

这里说明下，volatile易变的，可变的，一般用于以下几种状况：

1）并行设备的硬件寄存器（如：状态寄存器）

2）一个中断服务子程序中会访问到的非自动变量（Non-automatic variables)

3）多线程应用中被几个任务共享的变量

volatile可以解决用户模式和异常中断访问同一个变量时，出现的不同步问题，另外在访问硬件地址时，volatile也阻止对地址访问的优化，从而确保访问的实际的地址，精通volatile的运用，在嵌入式底层中十分重要，也是嵌入式C从业者的基本要求之一。函数指针在一般嵌入式软件的开发中并不常见，但对许多重要的实现如异步回调，驱动模块，使用函数指针就可以利用简单的方式实现很多应用，当然我这里只能说是抛砖引玉，许多细节知识是值得详细去了解掌握的。

#### 结构类型和对齐

C语言提供自定义数据类型来描述一类具有相同特征点的事务，主要支持的有结构体，枚举和联合体。其中枚举通过别名限制数据的访问，可以让数据更直观，易读，实现如下：
```c
typedef enum {spring=1, summer, autumn, winter }season;

season s1 = summer;
```

联合体的是能在同一个存储空间里存储不同类型数据的数据类型，对于联合体的占用空间，则是以其中占用空间最大的变量为准，如下：

```c
typedef union{     
  char c;     
  short s;     
  int i; 
}UNION_VAL;
 
UNION_VAL val; 
int main(void) 
{     
  printf("addr:0x%x, 0x%x, 0x%x\n",            
         (int)(&(val.c)), (int)(&(val.s)), (int)(&(val.i)));     
  val.i = 0x12345678;     
  if(val.s == 0x5678)         
    printf("小端模式\n");       
  else         
    printf("大端模式\n");     
} 
/*
addr:0x407970, 0x407970, 0x407970 
小端模式
*/

```

联合体的用途主要通过共享内存地址的方式，实现对数据内部段的访问，这在解析某些变量时，提供了更为简便的方式，此外测试芯片的大小端模式也是联合体的常见应用，当然利用指针强制转换，也能实现该目的,实现如下：

```c
int data = 0x12345678; 
short *pdata = (short *)&data; 
if(*pdata = 0x5678)     
  printf("%s\n", "小端模式"); 
else   
  printf("%s\n", "大端模式");
```

可以看出使用联合体在某些情况下可以避免对指针的滥用。

结构体则是将具有共通特征的变量组成的集合，比起C++的类来说，它没有安全访问的限制，不支持直接内部带函数，但通过自定义数据类型，函数指针，仍然能够实现很多类似于类的操作，对于大部分嵌入式项目来说，结构化处理数据对于优化整体架构以及后期维护大有便利，下面举例说明：
```c

typedef int (*pfunc)(int, int); 
typedef struct{     
  int num;     
  int profit;     
  pfunc get_total; 
}STRUCT_VAL;
  
int GetTotalProfit(int a, int b)
{     
  return a*b; 
}  

int main(void){     
  STRUCT_VAL Val;     
  STRUCT_VAL *pVal;      
  Val.get_total = GetTotalProfit;     
  Val.num = 1;     
  Val.profit = 10;     
  printf("Total:%d\n",  Val.get_total(Val.num, Val.profit));  //变量访问    
  pVal = &Val;     
  printf("Total:%d\n",  pVal->get_total(pVal->num, pVal->profit)); //指针访问 
} 
/* 
Total:10 
Total:10 
*/
```

C语言的结构体支持指针和变量的方式访问，通过转换可以解析任意内存的数据(如我们之前提到的通过指针强制转换解析协议)，另外通过将数据和函数指针打包，在通过指针传递，是实现驱动层实接口切换的重要基础，有着重要的实践意义，另外基于位域，联合体，结构体，可以实现另一种位操作，这对于封装底层硬件寄存器具有重要意义，实践如下：

```c

typedef unsigned char uint8_t; 
  union reg{     
    struct{         
    uint8_t bit0:1;         
    uint8_t bit1:1;         
    uint8_t bit2_6:5;         
    uint8_t bit7:1;     
  }bit;     
  uint8_t all; 
}; 

int main(void)
{     
  union reg RegData;     
  RegData.all = 0;      
  RegData.bit.bit0 = 1;     
  RegData.bit.bit7 = 1;     
  printf("0x%x\n", RegData.all);      
  RegData.bit.bit2_6 = 0x3;     
  printf("0x%x\n", RegData.all); 
} 
/* 
0x81 
0x8d
*/
```

通过联合体和位域操作，可以实现对数据内bit的访问，这在寄存器以及内存受限的平台，提供了简便且直观的处理方式，另外对于结构体的另一个重要知识点就是对齐了，通过对齐访问，可以大幅度提高运行效率，但是因为对齐引入的存储长度问题，也是容易出错的问题，对于对齐的理解，可以分类为如下说明。
基础数据类型：以默认的的长度对齐，如char以1字节对齐，short以2字节对齐等。

数组 ：按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。

联合体 ：按其包含的长度最大的数据类型对齐。

结构体：结构体中每个数据类型都要对齐，结构体本身以内部最大数据类型长度对齐

```c
union DATA{     
  int a;     
  char b; 
};  
struct BUFFER0{     
  union DATA data;     
  char a;     
  //reserved[3]     
  int b;     
  short s;     
  //reserved[2] 
}; //16字节  
struct BUFFER1{     
  char a;              
  //reserved[0]     
  short s;    
  union DATA data;     
  int b; 
};//12字节  

int main(void) 
{     
  struct BUFFER0 buf0;     
  struct BUFFER1 buf1;          
  printf("size:%d, %d\n", sizeof(buf0), sizeof(buf1));     
  printf("addr:0x%x, 0x%x, 0x%x, 0x%x\n",              
       (int)&(buf0.data), (int)&(buf0.a), (int)&(buf0.b), (int)&(buf0.s));          
  printf("addr:0x%x, 0x%x, 0x%x, 0x%x\n",              
       (int)&(buf1.a), (int)&(buf1.s), (int)&(buf1.data), (int)&(buf1.b)); 
} 
/* 
size:16, 12 
addr:0x61fe10, 0x61fe14, 0x61fe18, 0x61fe1c 
addr:0x61fe04, 0x61fe06, 0x61fe08, 0x61fe0c 
*/
```

其中union联合体的大小与内部最大的变量int一致，为4字节，根据读取的值，就知道实际内存布局和填充的位置是一致，事实上学会通过填充来理解C语言的对齐机制，是有效且快捷的方式。

#### 预处理机制

C语言提供了丰富的预处理机制，方便了跨平台的代码的实现，此外C语言通过宏机制实现的数据和代码块替换，字符串格式化，代码段切换，对于工程应用具有重要意义，下面按照功能需求，描述在C语言运用中的常用预处理机制。

#include 包含文件命令，在C语言中，它执行的效果是将包含文件中的所有内容插入到当前位置，这不只包含头文件，一些参数文件，配置文件，也可以使用该文件插入到当前代码的指定位置。其中<>和""分别表示从标准库路径还是用户自定义路径开始检索。

#define宏定义，常见的用法包含定义常量或者代码段别名，当然某些情况下配合##格式化字符串，可以实现接口的统一化处理，实例如下：
```c
#define MAX_SIZE  10
#define MODULE_ON  1
#define ERROR_LOOP() do{\
                     printf("error loop\n");\
                   }while(0);
#define global(val) g_##val
int global(v) = 10;
int global(add)(int a, int b)
{
    return a+b;
｝
```

#if..#elif...#else...#endif， #ifdef..#endif, #ifndef...#endif条件选择判断，条件选择主要用于切换代码块，这种综合性项目和跨平台项目中为了满足多种情况下的需求往往会被使用。

#undef 取消定义的参数，避免重定义问题。

#error，#warning用于用户自定义的告警信息，配合#if，#ifdef使用，可以限制错误的预定义配置。

#pragma 带参数的预定义处理，常见的#pragma pack(1), 不过使用后会导致后续的整个文件都以设置的字节对齐，配合push和pop可以解决这种问题，代码如下：

```c
#pragma pack(push)
#pragma pack(1)
struct TestA
{
   char i;
   int b;
}A;
#pragma pack(pop); //注意要调用pop，否则会导致后续文件都以pack定义值对齐，执行不符合预期
等同于
 struct _TestB{  
   char i;
   int b;
 }__attribute__((packed))A;
```
#### 总结

如果你看到了这里，那么应该对C语言有了比较清晰的认识，嵌入式C语言在处理硬件物理地址，位操作，内存访问，都给予开发者了充分的自由，通过数组，指针以及强制转换的技巧，可以有效减少数据处理中的复制过程，这对于底层是必要的，也方便了整个架构的开发。但是由这种自由带来的非法访问，溢出，越界，以及不同硬件平台对齐，数据宽度，大小端问题，在功能设计人员手里一般还能够处理，对于后续接手项目的人来说，如果本身的设计没有考虑清楚这些问题，往往代表着问题和麻烦，所以对于任何嵌入式C的从业者，清晰的掌握这些基础的知识和必要的。

#### C语言链接脚本

链接脚本一般用于MCU，SOC应用开发很少要写链接脚本的，只需要编译脚本。kernel,uboot之类的需要链接脚本。

这个链接是基础教程，可以看一下：

https://github.com/iDalink/ld-linker-script

1. 查看RAM，PFlash的大小。
2. 看一下链接脚本的入口地址和入口标签。
3. 要一下项目的Memory Map表。这个真的非常重要。
4. 看一下text段，bss段，data段有多少个子标签，一般以bss.xxxx data.xxx，data.xxx存在。
5. 看一下Memmap.h文件。看：宏定义对应的段在核几，在链接脚本的哪个位置。
6. 变量还要知道它的对齐方式，注意这边有编译器差异，有时候编译器会帮你对齐，有时候链接脚本指定对齐方式。
7. 有没有不在链接脚本中的内存占用。这个属于特殊用法，大家可以在项目中实战。这个设计很有意思。
8. 查看链接脚本中的特殊标签。这些带有start，end的标签也是需要关注的，可以帮助自己理解链接划分的结果。
9. 特殊的段标签。bss和data段的区别在于bss未初始化，data初始化了。问题来了，谁在初始化，怎么初始化的。第六点的标签是可以在代码中使用的变量，根据标签可以初始化数据（拷贝，赋0等操作），用SDK的话在main函数之前仔初始化的。注意看一下保护段，非保护段，功能安全相关的段，栈，堆等相关的位置。
10. 查阅编译器手册，链接脚本怎么写，编译器手册会告诉你。就是有点厚，其他没啥。
11. 是否存在特别寻址的段，如果没记错的话，Ifx存在small  data寻址，可以上下寻址多少K（32K总计64K，还是上下寻址64K）。这种特殊段可以加快访问速度。用于特殊优化。
12. 代码编译的最后的结果可以查看xxx.map文件。

#### struct结构体和union联合体

struct即结构体，C程序中经常需要用相关的不同类型的数据来描述一个数据对象。例如，描述学生的综合信息时，需要使用学生的学号、姓名、性别等不同类型的数据时，像这种数据类型总是在一起出现，那么我们不如把这些变量装入同一个“文件夹”中，这时用的关键字struct声明的一种数据类型就是表示这个“文件夹”的使用。那么在说明和使用之前必须先定义它，也就是构造它。如同在说明和调用函数之前要先定义一样。

结构体是一种集合，它里面包含了多个变量或数组，它们的类型可以相同，也可以不同，每个这样的变量或数组都称为结构体的成员，结构体也是一种数据类型，它由程序员自己定义，可以包含多个其他类型的数据，成员又称为成员变量，它是结构体所包含的若干个基本的结构类型，必须用“{}”括起来，并且要以分号结束，每个成员应表明具体的数据类型，成员一般用名字访问。结构体和数组类似，也是一组数据的集合，整体使用没有太大的意义。数组使用下标[ ]获访问元素，结构体使用点号.访问单个成员。通过这种方式可以获取成员的值，也可以给成员赋值

数组：a[0]=10;  结构体：today.day  (指针结构体用->访问)结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。

声明定义结构：

struct关键字+结构体的标志名+大括号里边是成员+}后面的声明此结构变量+末尾分号，一般有这些：

```c
struct week{定义一
  int x;
  char y;  
 };  
struct week p1,p2;  
//声明变量p1,p2,里边都是week的值          
//里边有x和y的值  
//用.访问 ：p1.x  p2.x// p1.y, p2.y

struct{定义二                     
int x;  
char y;            
}p1,p2;//在这里声明变量
//p1和p2都是一种无名结构，
// 里边有X和y  访问一样用.

struct week {定义三
   int x; 
   int y;
}p1,p2;
//常用的一种结构定义声明形式  

对于第一和第三种形式，都声明了结构名week，但是第二种没有声明结构名,只是定义了两个结构变量，
这种叫无名结构

无名结构： 可以定义无名结构体类型的变量。编译器对无名结构体的处理是随机生成一个不重复的变量名。
无名结构的定义方式就是定义无名结构体时必须定义该结构体类型的至少一个变量。

优点：无名结构体的妙用就是可以避免相同类型的结构体的重复定义，
这样可以对每一个具体类型的队列都可以定义一个结构体来管理该队列的头尾指针，
即使定义多个相同具体类型的队列也不会引发重复定义的编译错误。这样定义了两个队列，
其元素类型均为int类型，同时各得到了一个维护队列头尾指针的结构体

缺点：这里定义了一个无名的结构体，同时声明了三个此种类型的变量。
但是，因为没有名字，我们在这句之后，无法内再定义与那三种变量相同类型的变量了。
除非你再容次去定义一个这样的相同的结构体类型。
还有一个重要的原因就是没有办法在其他位置定义我们所需要的结构体变量，
每次需要新定义结构体变量的时候都必须要找到最开始结构体代码书写的位置才能定义新的结构体  
  
所以实际编程中无名结构并不常用

```

注意：

1、结构体本身并不会被作为数据而开辟内存，真正作为数据而在内存中存储的是这种结构体所定义的变量。

2、先声明结构体类型，再定义该类型的变量，声明结构体类型，不分配空间定义结构体类型变量，就要分配内存空间

3、量使用占为少的类型,如,在可能的时候使用short代替int，按数据类型本身占用的位置从大到小排

4、除了可以对成员进行逐一赋值，也可以在定义时整体赋值：p1={struct week}{5,10}; 相当于 p1.x=5,p1.y=10;

p1=p2 表示 p1.x=p2.x ,  p1.y=p2.y; 不过整体赋值仅限于定义结构体变量的时候，在使用过程中只能对成员逐一赋值

5、结构体变量不能相加，相减，也不能相互乘除，但结构体可以相互赋值，也就是说，可以将一个结构体变量赋值给另一个结构体变量。但是前提是这两个结构体变量的结构体类型必须相同

结构体的运算：要访问整个结构，直接用结构变量的名字，对于整个结构，可以做赋值，取地址，也可以传递给函数参数

结构体数值
嵌套的结构体：
```c

struct week{
int x;
int y;
strcut week at;//在结构体又定义了名为at的一个和week同样参数的结构体变量
        //其中可以用.运算符访问  see.at.x see.at.y
}see;
但是其实这样的方式是不建议（非法）的，因为这种声明实际上是一个无限循环，成员at是一个结构体，
at的内部还会有成员是结构体，依次下去，无线循环。在分配内存的时候，由于无限嵌套，
也无法确定这个结构体的长度，所以这种方式是非法的
正确的方式是使用《结构体指针》，因为指针的长度是确定的:

struct week{
int x;
int y;
strcut week *at;//在结构体内定义了一个指向和week一样类型的结构指针
}see;          但是注意用指针访问时要用->运算符   see.at->x
```







#### C语言进行json的序列化和反序列
##### 前言
json是目前最为流行的文本数据传输格式，特别是在网络通信上广泛应用，随着物联网的兴起，在嵌入式设备上，也需要开始使用json进行数据传输，那么，如何快速简洁地用C语言进行json的序列化和反序列化呢？

当前，应用最广泛的C语言json解析库当属cJSON，但是，使用cJSON读json进行序列化和反序列化，需要根据key一个一个进行处理，会导致代码冗余，逻辑性不强，哪有没有更好的方法呢？

思路在Android平台，一般会使用gson等工具解析json，这些工具将json直接映射成对象，在C语言上使用对象的概念，我们需要借助结构体，然而，最大的问题在于，C语言没有高级语言具有的反射机制，直接从json映射到结构体对象几乎是不可能的。
怎么解决呢，既然C语言没有反射机制，那么我们可以自己定义一套类似于反射的机制，这里我将其称之为结构体数据模型，在数据模型中，我们需要准确地描述结构体的特征，包括结构体各成员的名称，类型，在结构体中的偏移。
有了这些，我们可以在解析josn的时候，将解析得到的数据直接写入到对应的内存里面去，或者是在序列化的时候，直接从对应的内存中读取数据，进行处理。

实现CSON正是采用上面说到的思路，使用数据模型对结构体进行描述，然后基于cJSON，根据数据模型进行解析，将解析得到的数据直接写入到对应的内存区域，从而实现从json到结构体对象的映射。
CSON最基本的数据模型定义如下：
```c
typedef struct cson_model
{
    CsonType type;                      /**< 数据类型 */
    char *key;                          /**< 元素键值 */
    short offset;                       /**< 元素偏移 */
} CsonModel;
```
通过type描述结构体成员的数据类型，key描述该成员在json中对应的字段，offset描述该结构体成员在结构体中的偏移，CSON在解析json的时候，根据type调用相应的cJSON API并传递key作为参数，得到解析出的数据，然后根据offset将数据写入到对应的内存空间。
比如说这样一个结构体：
```c
struct project
{
    int id;
    char *name;
}
```
该结构体包含两个成员，对于成员id，我们使用数据模型对其进行描述
```c
{.type=CSON_TYPE_CHAR, key="id", offset=0}
```

对于结构体的每个成员，都进行数据模型的定义，就可以得到一个完整的结构体数据模型，CSON会根据这个模型，进行解析。
因为是通过直接写内存的方式，所以在写不同类型的量到内存中时，会多次用到强制转型，导致CSON中赋值的代码都类似于：
```c
*(int *)((int)obj + model[i].offset) = (int)csonDecodeNumber(json, model[i].key);
```

当然，上面说到的数据模型，只适用于基本数据类型的数据，对于子结构体，链表，数组等，需要对数据模型的定义进行扩充，有兴趣的朋友可以直接阅读CSON源码。
CSON使用实例

声明结构体：
/** 项目结构体 */
struct project
{
    int id;
    char *name;
};

/** 仓库结构体 */
struct hub
{
    int id;
    char *user;
    struct project *cson;
};

定义数据模型：
对每一个需要使用cson的结构体，都需要定义相对应的数据模型

```c
/** 项目结构体数据模型 */
CsonModel projectModel[] =
{
    CSON_MODEL_OBJ(struct project),
    CSON_MODEL_INT(struct project, id),
    CSON_MODEL_STRING(struct project, name),
};

/** 仓库结构体数据模型 */
CsonModel hubModel[] =
{
    CSON_MODEL_OBJ(struct hub),
    CSON_MODEL_INT(struct hub, id),
    CSON_MODEL_STRING(struct hub, user),
    CSON_MODEL_STRUCT(struct hub, cson, projectModel, sizeof(projectModel)/sizeof(CsonModel))
};
```

使用CSON解析：
只需要定义好数据模型，就可以使用CSON读json进行序列化和反序列化

```c
void csonDemo(void)
{
    char *jsonDemo = "{\"id\": 1, \"user\": \"Letter\", \"cson\": {\"id\": 2, \"name\": \"cson\"}}";

    /** 解析json */
    struct hub *pHub = csonDecode(jsonDemo, hubModel, sizeof(hubModel)/sizeof(CsonModel));
    printf("hub: id: %d, user: %s, project id: %d, project name: %s\r\n",
        pHub->id, pHub->user, pHub->cson->id, pHub->cson->name);

    /** 序列化对象 */
    char *formatJson = csonEncodeFormatted(pHub, hubModel, sizeof(hubModel)/sizeof(CsonModel));
    printf("format json: %s\r\n", formatJson);

    /** 释放结构体对象 */
    csonFree(pHub, hubModel, sizeof(hubModel)/sizeof(CsonModel));

    /** 释放序列化生成的json字符串 */
    csonFreeJson(formatJson);
}
```

运行结果：
```c
hub: id: 1, user: Letter, project id: 2, project name: cson
format json: {
        "id":   1,
        "user": "Letter",
        "cson": {
                "id":   2,
                "name": "cson"
        }
}
```

可以看到，无论是解析json，还是序列化结构体到json，在使用CSON的情况下，都只需要一行代码就可以解决，同样的操作，在使用原生cJSON的情况下，你可能需要多次判断，解析元素。
CSON地址:https://github.com/NevermindZZT/cson。


### 浅谈嵌入式MCU软件开发之中断优先级与中断嵌套；

### 浅谈嵌入式MCU软件开发之应用工程的堆与栈；

### 浅谈嵌入式MCU软件开发之代码风格与代码优化；

### 浅谈嵌入式MCU硬件设计之电源与复位电路设计；

### 浅谈嵌入式MCU软件开发之startup过程详解(从复位向量到main函数之前的准备工作)；

### 参考文献
1、关于语言特性

- Stephen Prata 著 云巅工作室 译 《C Primer Plus（第五版）中文版》
- Andrew Koenig 著 高巍 译 《C陷阱与缺陷》
- Peter Van Der Linden 著 徐波 译 《C专家编程》
- 陈正冲 编著 《C语言深度解剖》
  
2、关于编译器

- 杜春雷 编著 《ARM体系结构与编程》
- Keil MDK 编译器帮助手册

3、关于防御性编程

- MISRA-C-:2004 Guidelines for the use of the C language in criticalsystems
- Robert C.Seacord 著 徐波 译 《C安全编码标准》

4、关于编程思想

- Pete Goodliffe 著 韩江、陈玉 译 《编程匠艺---编写卓越的代码》
- Susan Lammers 著 李琳骁、吴咏炜、张菁《编程大师访谈录》
## ARM体系架构学习

## 车规级和工业级MCU外设资源汇总学习

### 工业级

#### 工业MCU专栏

#### 工业总线通信
##### 片上外设使用tips之MCU的心跳之源--时钟(内部IRC与外部时钟)

##### 片上外设使用tips之TIM定时器使用；

##### 片上外设使用tips之GPIO使用；

##### 片上外设使用tips之COP看门狗使用；

##### 片上外设使用tips之SAR ADC使用；

##### 片上外设使用tips之MSCAN使用；

##### 片上外设使用tips之UART/SCI使用；

##### 片上外设使用tips之I2C使用；

##### 片上外设使用tips之SPI使用；

##### 片上外设使用tips之FlexCAN使用；

##### 片上外设使用tips之DCU使用；

##### 片上外设使用tips之eMIOS使用；

##### 片上外设使用tips之Flash加密(security)与保护(protection；

##### 片上外设使用tips之片上memory ECC工作机制与使用；

### 车规级

#### 汽车电子总线技术科普之LIN总线；

#### 汽车电子总线技术科普之CAN总线；

#### 汽车电子总线技术科普之FlexRay总线；

#### 汽车电子总线技术科普之Ethernet总线；


## TinyML MCU学习

## 嵌入式微控制器设计（SoC和FPGA）

## 嵌入式DSP设计

## 可重构计算（FPGA）

## 集成电路测试指南


