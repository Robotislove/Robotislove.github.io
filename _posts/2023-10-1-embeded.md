---
layout: post
title: ARM Cortex-M学习笔记
date: 2023-10-1
author: lau
tags: [DL, Note]
comments: true
toc: true
pinned: false
---

ARM Cortex-M学习笔记。

<!-- more -->

首先是ARM Cortex-M的学习资源汇总，这里包含书籍和学习参考资源。

## 嵌入式学习资源汇总
### 官方资源和手册参考
#### 中文参考手册

| 类别                                   | 资源                                                                     | 版本                                                   | 短评                                                          
|--------------------------------------|------------------------------------------------------------------------|------------------------------------------------------|--------------------------------------------------------------|
| 官方汇总                                 | cortex-m-resources                                                     | /                                                    | ARM公司专家Joseph Yiu收集整理的所有对开发者有用的官方Cortex-M资料链接（也包含极少资源链接）  |
| 概念科普                                 | Cortex-M ARM官方主页                                                       | /                                                    | 最权威的Cortex-M资源来源，最新的Cortex-M技术应该从这里去找                        
| ARM_Cortex-M维基百科                     | /                                                                      | 对于技术名词的解释，Wikipedia是非常专业的，wiki最后还给出Cortex-M相关资源下载链接  | /                                                        
| ARM Cortex-M for Beginners           | /                                                                      | /                                                    | /                                                            |   
| ARM Cortex-M处理器入门                    | v3                                                                     | /                                                    | /                                                           
| 2017 March                           | ARM公司专家Joseph Yiu写的白皮书，可以说一篇文章让你看懂Cortex-M0/M0+/M1/M3/M4/M7/M23/M33差异  | /                                                    | /                                            | 
| 内核手册                                 | ARMv6/v7/v8-M Architecture Reference Manual                            | /                                                    | ARM Cortex-M内核架构参考手册，还有比这个更权威的资料么？              
| Cortex-Mx Technical Reference Manual | /                                                                      | ARM Cortex-M处理器技术参考手册，还有比这个更权威的资料么？                  | /                                     |  
| Cortex-Mx Devices Generic User Guide | /                                                                      | ARM Cortex-M芯片使用指南，还有比这个更权威的资料么？                     | /                                       |  

#### 英文参考手册
Arm Helium Technology M-Profile Vector Extension (MVE) for Arm Cortex-M Processor (reference book)
Available here: https://www.arm.com/resources/education/books/mve-reference-book。
https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/cortex-m-resources。
### 书籍推荐
1. ARM Cortex-M0 全可编程SoC原理及实现
2. 嵌入式微控制器与处理器设计
3. Cortex-M4，M3，M0权威指南（中英文版）

## 嵌入式C语言汇总
### 嵌入式C常见用法
#### 关键词

关键字是C语言中具有特殊功能的保留标示符，按照功能可分为

1). 数据类型(常用char, short, int, long, unsigned, float, double)

2). 运算和表达式( =, +, -, *, while, do-while, if, goto, switch-case)

3). 数据存储(auto， static， extern，const， register，volatile，restricted)，

4). 结构(struct, enum, union,typedef),

5). 位操作和逻辑运算(<<, >>, &, |, ~，^, &&)，

6). 预处理(#define, #include, #error，#if...#elif...#else...#endif等)，

7). 平台扩展关键字(__asm, __inline，__syscall)

这些关键字共同构成了嵌入式平台的C语法。

嵌入式的应用从逻辑上可以抽象为三个部分：

1). 数据的输入(如传感器，信号，接口输入),

2). 数据的处理(如协议的解码和封包，AD采样值的转换等)

3). 数据的输出(GUI的显示，输出的引脚状态，DA的输出控制电压，PWM波的占空比等)，
对于数据的管理就贯穿着整个嵌入式应用的开发，它包含数据类型，存储空间管理，位和逻辑操作，以及数据结构，C语言从语法上支撑上述功能的实现，并提供相应的优化机制，以应对嵌入式下更受限的资源环境。

#### 数据类型

C语言支持常用的字符型，整型，浮点型变量，有些编译器如keil还扩展支持bit(位)和sfr(寄存器)等数据类型来满足特殊的地址操作。C语言只规定了每种基本数据类型的最小取值范围，因此在不同芯片平台上相同类型可能占用不同长度的存储空间，这就需要在代码实现时考虑后续移植的兼容性，而C语言提供的typedef就是用于处理这种情况的关键字，在大部分支持跨平台的软件项目中被采用，典型的如下:

```c
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
......
typedef signed int int32_t;
```

既然不同平台的基本数据宽度不同，那么如何确定当前平台的基础数据类型如int的宽度，这就需要C语言提供的接口sizeof，实现如下。

```c
printf("int size:%d, short size:%d, char size:%d\n", sizeof(int), sizeof(char), sizeof(short));
```

这里还有重要的知识点，就是指针的宽度，如
```c
char *p；
printf("point p size:%d\n", sizeof(p));
```
其实这就和芯片的可寻址宽度有关，如32位MCU的宽度就是4，64位MCU的宽度就是8，在有些时候这也是查看MCU位宽比较简单的方式。

#### 内存管理和存储架构

C语言允许程序变量在定义时就确定内存地址，通过作用域，以及关键字extern，static，实现了精细的处理机制，按照在硬件的区域不同，内存分配有三种方式(节选自C++高质量编程)：

1). 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。

2). 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中 ，效率很高，但是分配的内存容量有限。

3). 从堆上分配，亦称动态内存分配。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但同时遇到问题也最多。
这里先看个简单的C语言实例。

```c
//main.c#include <stdio.h>#include <stdlib.h>

static int st_val;                   //静态全局变量 -- 静态存储区
int ex_val;                           //全局变量 -- 静态存储区int main(void)
{
   int a = 0;                         //局部变量 -- 栈上申请
   int *ptr = NULL;                   //指针变量
   static int local_st_val = 0;       //静态变量
   local_st_val += 1;
   a = local_st_val;
   ptr = (int *)malloc(sizeof(int)); //从堆上申请空间
   if(ptr != NULL)
   {      
    printf("*p value:%d", *ptr);
    free(ptr);      
    ptr = NULL;      
    //free后需要将ptr置空，否则会导致后续ptr的校验失效，出现野指针   
    }            
}
```

C语言的作用域不仅描述了标识符的可访问的区域，其实也规定了变量的存储区域，在文件作用域的变量st_val和ex_val被分配到静态存储区，其中static关键字主要限定变量能否被其它文件访问，而代码块作用域中的变量a, ptr和local_st_val则要根据类型的不同，分配到不同的区域，其中a是局部变量，被分配到栈中，ptr作为指针，由malloc分配空间，因此定义在堆中，而local_st_val则被关键字限定，表示分配到静态存储区，这里就涉及到重要知识点，static在文件作用域和代码块作用域的意义是不同的：在文件作用域用于限定函数和变量的外部链接性(能否被其它文件访问), 在代码块作用域则用于将变量分配到静态存储区。

对于C语言，如果理解上述知识对于内存管理基本就足够，但对于嵌入式C来说，定义一个变量，它不一定在内存(SRAM)中，也有可能在FLASH空间，或直接由寄存器存储(register定义变量或者高优化等级下的部分局部变量)，如定义为const的全局变量定义在FLASH中，定义为register的局部变量会被优化到直接放在通用寄存器中，在优化运行速度，或者存储受限时，理解这部分知识对于代码的维护就很有意义。此外，嵌入式C语言的编译器中会扩展内存管理机制，如支持分散加载机制和__attribute__((section("用户定义区域")))，允许指定变量存储在特殊的区域如(SDRAM, SQI FLASH), 这强化了对内存的管理，以适应复杂的应用环境场景和需求。

```c
LD_ROM 0x00800000 0x10000 { ;load region size_region
    EX_ROM 0x00800000 0x10000 { ;load address = execution address
  *.o (RESET, +First)
  *(InRoot$$Sections)
  .ANY (+RO)
  }
  EX_RAM 0x20000000 0xC000 { ;rw Data
    .ANY (+RW +ZI)
  }
  EX_RAM1 0x2000C000 0x2000 {
    .ANY(MySection)
   }
  EX_RAM2 0x40000000 0x20000{
    .ANY(Sdram)
  }
}

int a[10] __attribute__((section("Mysection")));
int b[100] __attribute__((section("Sdram")));
```

采用这种方式，我们就可以将变量指定到需要的区域，这在某些情况下必须的，如做GUI或者网页时因为要存储大量图片和文档，内部FLASH空间可能不足，这时就可以将变量声明到外部区域，另外内存中某些部分的数据比较重要，为了避免被其它内容覆盖，可能需要单独划分SRAM区域，避免被误修改导致致命性的错误，这些经验在实际的产品开发中是常用且重要，不过因为篇幅原因，这里只简略的提供例子，如果工作中遇到这种需求，建议详细去了解下。

至于堆的使用，对于嵌入式Linux来说，使用起来和标准C语言一致，注意malloc后的检查，释放后记得置空，避免"野指针“，不过对于资源受限的单片机来说，使用malloc的场景一般较少，如果需要频繁申请内存块的场景，都会构建基于静态存储区和内存块分割的一套内存管理机制，一方面效率会更高(用固定大小的块提前分割，在使用时直接查找编号处理)，另一方面对于内存块的使用可控，可以有效避免内存碎片的问题，常见的如RTOS和网络LWIP都是采用这种机制，我个人习惯也采用这种方式，所以关于堆的细节不在描述，如果希望了解，可以参考<C Primer Plus>中关于存储相关的说明。

#### 指针和数组

数组和指针往往是引起程序bug的主要原因，如数组越界，指针越界，非法地址访问，非对齐访问，这些问题背后往往都有指针和数组的影子，因此理解和掌握指针和数组，是成为合格C语言开发者的必经之路。

数组是由相同类型元素构成，当它被声明时，编译器就根据内部元素的特性在内存中分配一段空间，另外C语言也提供多维数组，以应对特殊场景的需求，而指针则是提供使用地址的符号方法，只有指向具体的地址才有意义，C语言的指针具有最大的灵活性，在被访问前，可以指向任何地址，这大大方便了对硬件的操作，但同时也对开发者有了更高的要求。参考如下代码。

```c
int main(void)
{
  char cval[] = "hello";
  int i;
  int ival[] = {1, 2, 3, 4};
  int arr_val[][2] = {{1, 2}, {3, 4}};
  const char *pconst = "hello";
  char *p;
  int *pi;
  int *pa;
  int **par;

  p = cval;
  p++;            //addr增加1
  pi = ival;
  pi+=1;          //addr增加4
  pa = arr_val[0];
  pa+=1;          //addr增加4
  par = arr_val;
  par++;         //addr增加8
  for(i=0; i<sizeof(cval); i++)
  {
      printf("%d ", cval[i]);
  }
  printf("\n");
  printf("pconst:%s\n", pconst);
  printf("addr:%d, %d\n", cval, p);
  printf("addr:%d, %d\n", icval, pi);
  printf("addr:%d, %d\n", arr_val, pa);
  printf("addr:%d, %d\n", arr_val, par);
}

/* PC端64位系统下运行结果
0x68 0x65 0x6c 0x6c 0x6f 0x0
pconst:hello
addr:6421994, 6421995
addr:6421968, 6421972
addr:6421936, 6421940
addr:6421936, 6421944 */
```

对于数组来说，一般从0开始获取值，以length-1作为结束，通过[0, length)半开半闭区间访问，这一般不会出问题，但是某些时候，我们需要倒着读取数组时，有可能错误的将length作为起始点，从而导致访问越界，另外在操作数组时，有时为了节省空间，将访问的下标变量i定义为unsigned char类型，而C语言中unsigned char类型的范围是0~255，如果数组较大，会导致数组超过时无法截止，从而陷入死循环，这种在最初代码构建时很容易避免，但后期如果更改需求，在加大数组后，在使用数组的其它地方都会有隐患，需要特别注意。

在前面提到过，指针占有的空间与芯片的寻址宽度有关，32位平台为4字节，64位为8字节，而指针的加减运算中的长度又与它的类型相关，如char类型为1，int类型为4，如果你仔细观察上面的代码就会发现par的值增加了8，这是因为指向指针的指针，对应的变量是指针，也就是长度就是指针类型的长度，在64位平台下为8，如果在32位平台则为4，这些知识理解起来并不困难，但是这些特性在工程运用中稍有不慎，就会埋下不易察觉的问题。另外指针还支持强制转换，这在某些情况下相当有用，参考如下代码：
```c
#include <stdio.h>

typedef struct
{
  int b;
  int a;
}STRUCT_VAL;
static __align(4) char arr[8] = {0x12, 0x23, 0x34, 0x45, 0x56, 0x12, 0x24, 0x53};
int main(void)
{
    STRUCT_VAL *pval;
    int *ptr;
    pval = (STRUCT_VAL *)arr;
    ptr = (int *)&arr[4];
    printf("val:%d, %d", pval->a, pval->b);
    printf("val:%d,", *ptr);
}
//0x45342312 0x53241256
//0x53241256
```

基于指针的强制转换，在协议解析，数据存储管理中高效快捷的解决了数据解析的问题，但是在处理过程中涉及的数据对齐，大小端，是常见且十分易错的问题，如上面arr字符数组，通过__align(4)强制定义为4字节对齐是必要的，这里可以保证后续转换成int指针访问时，不会触发非对齐访问异常，如果没有强制定义，char默认是1字节对齐的，当然这并不就是一定触发异常(由整个内存的布局决定arr的地址，也与实际使用的空间是否支持非对齐访问有关，如部分SDRAM使用非对齐访问时，会触发异常), 这就导致可能增减其它变量，就可能触发这种异常，而出异常的地方往往和添加的变量毫无关系，而且代码在某些平台运行正常，切换平台后触发异常，这种隐蔽的现象是嵌入式中很难查找解决的问题。另外，C语言指针还有特殊的用法就是通过强制转换给特定的物理地址访问，通过函数指针实现回调，如下：

```c
#include <stdio.h>

typedef int (*pfunc)(int, int);
int func_add(int a, int b){
 return a+b;
}
int main(void)
{
    pfunc *func_ptr;
    *（volatile uint32_t *）0x20001000 = 0x01a23131;
    func_ptr = func_add;
    printf("%d\n", func_ptr(1, 2));
}
```

这里说明下，volatile易变的，可变的，一般用于以下几种状况：

1）并行设备的硬件寄存器（如：状态寄存器）

2）一个中断服务子程序中会访问到的非自动变量（Non-automatic variables)

3）多线程应用中被几个任务共享的变量

volatile可以解决用户模式和异常中断访问同一个变量时，出现的不同步问题，另外在访问硬件地址时，volatile也阻止对地址访问的优化，从而确保访问的实际的地址，精通volatile的运用，在嵌入式底层中十分重要，也是嵌入式C从业者的基本要求之一。函数指针在一般嵌入式软件的开发中并不常见，但对许多重要的实现如异步回调，驱动模块，使用函数指针就可以利用简单的方式实现很多应用，当然我这里只能说是抛砖引玉，许多细节知识是值得详细去了解掌握的。

#### 结构类型和对齐

C语言提供自定义数据类型来描述一类具有相同特征点的事务，主要支持的有结构体，枚举和联合体。其中枚举通过别名限制数据的访问，可以让数据更直观，易读，实现如下：
```c
typedef enum {spring=1, summer, autumn, winter }season;

season s1 = summer;
```

联合体的是能在同一个存储空间里存储不同类型数据的数据类型，对于联合体的占用空间，则是以其中占用空间最大的变量为准，如下：

```c
typedef union{     
  char c;     
  short s;     
  int i; 
}UNION_VAL;
 
UNION_VAL val; 
int main(void) 
{     
  printf("addr:0x%x, 0x%x, 0x%x\n",            
         (int)(&(val.c)), (int)(&(val.s)), (int)(&(val.i)));     
  val.i = 0x12345678;     
  if(val.s == 0x5678)         
    printf("小端模式\n");       
  else         
    printf("大端模式\n");     
} 
/*
addr:0x407970, 0x407970, 0x407970 
小端模式
*/

```

联合体的用途主要通过共享内存地址的方式，实现对数据内部段的访问，这在解析某些变量时，提供了更为简便的方式，此外测试芯片的大小端模式也是联合体的常见应用，当然利用指针强制转换，也能实现该目的,实现如下：

```c
int data = 0x12345678; 
short *pdata = (short *)&data; 
if(*pdata = 0x5678)     
  printf("%s\n", "小端模式"); 
else   
  printf("%s\n", "大端模式");
```

可以看出使用联合体在某些情况下可以避免对指针的滥用。

结构体则是将具有共通特征的变量组成的集合，比起C++的类来说，它没有安全访问的限制，不支持直接内部带函数，但通过自定义数据类型，函数指针，仍然能够实现很多类似于类的操作，对于大部分嵌入式项目来说，结构化处理数据对于优化整体架构以及后期维护大有便利，下面举例说明：
```c

typedef int (*pfunc)(int, int); 
typedef struct{     
  int num;     
  int profit;     
  pfunc get_total; 
}STRUCT_VAL;
  
int GetTotalProfit(int a, int b)
{     
  return a*b; 
}  

int main(void){     
  STRUCT_VAL Val;     
  STRUCT_VAL *pVal;      
  Val.get_total = GetTotalProfit;     
  Val.num = 1;     
  Val.profit = 10;     
  printf("Total:%d\n",  Val.get_total(Val.num, Val.profit));  //变量访问    
  pVal = &Val;     
  printf("Total:%d\n",  pVal->get_total(pVal->num, pVal->profit)); //指针访问 
} 
/* 
Total:10 
Total:10 
*/
```

C语言的结构体支持指针和变量的方式访问，通过转换可以解析任意内存的数据(如我们之前提到的通过指针强制转换解析协议)，另外通过将数据和函数指针打包，在通过指针传递，是实现驱动层实接口切换的重要基础，有着重要的实践意义，另外基于位域，联合体，结构体，可以实现另一种位操作，这对于封装底层硬件寄存器具有重要意义，实践如下：

```c

typedef unsigned char uint8_t; 
  union reg{     
    struct{         
    uint8_t bit0:1;         
    uint8_t bit1:1;         
    uint8_t bit2_6:5;         
    uint8_t bit7:1;     
  }bit;     
  uint8_t all; 
}; 

int main(void)
{     
  union reg RegData;     
  RegData.all = 0;      
  RegData.bit.bit0 = 1;     
  RegData.bit.bit7 = 1;     
  printf("0x%x\n", RegData.all);      
  RegData.bit.bit2_6 = 0x3;     
  printf("0x%x\n", RegData.all); 
} 
/* 
0x81 
0x8d
*/
```

通过联合体和位域操作，可以实现对数据内bit的访问，这在寄存器以及内存受限的平台，提供了简便且直观的处理方式，另外对于结构体的另一个重要知识点就是对齐了，通过对齐访问，可以大幅度提高运行效率，但是因为对齐引入的存储长度问题，也是容易出错的问题，对于对齐的理解，可以分类为如下说明。
基础数据类型：以默认的的长度对齐，如char以1字节对齐，short以2字节对齐等。

数组 ：按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。

联合体 ：按其包含的长度最大的数据类型对齐。

结构体：结构体中每个数据类型都要对齐，结构体本身以内部最大数据类型长度对齐

```c
union DATA{     
  int a;     
  char b; 
};  
struct BUFFER0{     
  union DATA data;     
  char a;     
  //reserved[3]     
  int b;     
  short s;     
  //reserved[2] 
}; //16字节  
struct BUFFER1{     
  char a;              
  //reserved[0]     
  short s;    
  union DATA data;     
  int b; 
};//12字节  

int main(void) 
{     
  struct BUFFER0 buf0;     
  struct BUFFER1 buf1;          
  printf("size:%d, %d\n", sizeof(buf0), sizeof(buf1));     
  printf("addr:0x%x, 0x%x, 0x%x, 0x%x\n",              
       (int)&(buf0.data), (int)&(buf0.a), (int)&(buf0.b), (int)&(buf0.s));          
  printf("addr:0x%x, 0x%x, 0x%x, 0x%x\n",              
       (int)&(buf1.a), (int)&(buf1.s), (int)&(buf1.data), (int)&(buf1.b)); 
} 
/* 
size:16, 12 
addr:0x61fe10, 0x61fe14, 0x61fe18, 0x61fe1c 
addr:0x61fe04, 0x61fe06, 0x61fe08, 0x61fe0c 
*/
```

其中union联合体的大小与内部最大的变量int一致，为4字节，根据读取的值，就知道实际内存布局和填充的位置是一致，事实上学会通过填充来理解C语言的对齐机制，是有效且快捷的方式。

#### 预处理机制

C语言提供了丰富的预处理机制，方便了跨平台的代码的实现，此外C语言通过宏机制实现的数据和代码块替换，字符串格式化，代码段切换，对于工程应用具有重要意义，下面按照功能需求，描述在C语言运用中的常用预处理机制。

#include 包含文件命令，在C语言中，它执行的效果是将包含文件中的所有内容插入到当前位置，这不只包含头文件，一些参数文件，配置文件，也可以使用该文件插入到当前代码的指定位置。其中<>和""分别表示从标准库路径还是用户自定义路径开始检索。

#define宏定义，常见的用法包含定义常量或者代码段别名，当然某些情况下配合##格式化字符串，可以实现接口的统一化处理，实例如下：
```c
#define MAX_SIZE  10
#define MODULE_ON  1
#define ERROR_LOOP() do{\
                     printf("error loop\n");\
                   }while(0);
#define global(val) g_##val
int global(v) = 10;
int global(add)(int a, int b)
{
    return a+b;
｝
```

#if..#elif...#else...#endif， #ifdef..#endif, #ifndef...#endif条件选择判断，条件选择主要用于切换代码块，这种综合性项目和跨平台项目中为了满足多种情况下的需求往往会被使用。

#undef 取消定义的参数，避免重定义问题。

#error，#warning用于用户自定义的告警信息，配合#if，#ifdef使用，可以限制错误的预定义配置。

#pragma 带参数的预定义处理，常见的#pragma pack(1), 不过使用后会导致后续的整个文件都以设置的字节对齐，配合push和pop可以解决这种问题，代码如下：

```c
#pragma pack(push)
#pragma pack(1)
struct TestA
{
   char i;
   int b;
}A;
#pragma pack(pop); //注意要调用pop，否则会导致后续文件都以pack定义值对齐，执行不符合预期
等同于
 struct _TestB{  
   char i;
   int b;
 }__attribute__((packed))A;
```
#### 总结

如果你看到了这里，那么应该对C语言有了比较清晰的认识，嵌入式C语言在处理硬件物理地址，位操作，内存访问，都给予开发者了充分的自由，通过数组，指针以及强制转换的技巧，可以有效减少数据处理中的复制过程，这对于底层是必要的，也方便了整个架构的开发。但是由这种自由带来的非法访问，溢出，越界，以及不同硬件平台对齐，数据宽度，大小端问题，在功能设计人员手里一般还能够处理，对于后续接手项目的人来说，如果本身的设计没有考虑清楚这些问题，往往代表着问题和麻烦，所以对于任何嵌入式C的从业者，清晰的掌握这些基础的知识和必要的。

#### C语言链接脚本

链接脚本一般用于MCU，SOC应用开发很少要写链接脚本的，只需要编译脚本。kernel,uboot之类的需要链接脚本。

这个链接是基础教程，可以看一下：

https://github.com/iDalink/ld-linker-script

1. 查看RAM，PFlash的大小。
2. 看一下链接脚本的入口地址和入口标签。
3. 要一下项目的Memory Map表。这个真的非常重要。
4. 看一下text段，bss段，data段有多少个子标签，一般以bss.xxxx data.xxx，data.xxx存在。
5. 看一下Memmap.h文件。看：宏定义对应的段在核几，在链接脚本的哪个位置。
6. 变量还要知道它的对齐方式，注意这边有编译器差异，有时候编译器会帮你对齐，有时候链接脚本指定对齐方式。
7. 有没有不在链接脚本中的内存占用。这个属于特殊用法，大家可以在项目中实战。这个设计很有意思。
8. 查看链接脚本中的特殊标签。这些带有start，end的标签也是需要关注的，可以帮助自己理解链接划分的结果。
9. 特殊的段标签。bss和data段的区别在于bss未初始化，data初始化了。问题来了，谁在初始化，怎么初始化的。第六点的标签是可以在代码中使用的变量，根据标签可以初始化数据（拷贝，赋0等操作），用SDK的话在main函数之前仔初始化的。注意看一下保护段，非保护段，功能安全相关的段，栈，堆等相关的位置。
10. 查阅编译器手册，链接脚本怎么写，编译器手册会告诉你。就是有点厚，其他没啥。
11. 是否存在特别寻址的段，如果没记错的话，Ifx存在small  data寻址，可以上下寻址多少K（32K总计64K，还是上下寻址64K）。这种特殊段可以加快访问速度。用于特殊优化。
12. 代码编译的最后的结果可以查看xxx.map文件。

#### struct结构体和union联合体

struct即结构体，C程序中经常需要用相关的不同类型的数据来描述一个数据对象。例如，描述学生的综合信息时，需要使用学生的学号、姓名、性别等不同类型的数据时，像这种数据类型总是在一起出现，那么我们不如把这些变量装入同一个“文件夹”中，这时用的关键字struct声明的一种数据类型就是表示这个“文件夹”的使用。那么在说明和使用之前必须先定义它，也就是构造它。如同在说明和调用函数之前要先定义一样。

结构体是一种集合，它里面包含了多个变量或数组，它们的类型可以相同，也可以不同，每个这样的变量或数组都称为结构体的成员，结构体也是一种数据类型，它由程序员自己定义，可以包含多个其他类型的数据，成员又称为成员变量，它是结构体所包含的若干个基本的结构类型，必须用“{}”括起来，并且要以分号结束，每个成员应表明具体的数据类型，成员一般用名字访问。结构体和数组类似，也是一组数据的集合，整体使用没有太大的意义。数组使用下标[ ]获访问元素，结构体使用点号.访问单个成员。通过这种方式可以获取成员的值，也可以给成员赋值

数组：a[0]=10;  结构体：today.day  (指针结构体用->访问)结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。

声明定义结构：

struct关键字+结构体的标志名+大括号里边是成员+}后面的声明此结构变量+末尾分号，一般有这些：

```c
struct week{定义一
  int x;
  char y;  
 };  
struct week p1,p2;  
//声明变量p1,p2,里边都是week的值          
//里边有x和y的值  
//用.访问 ：p1.x  p2.x// p1.y, p2.y

struct{定义二                     
int x;  
char y;            
}p1,p2;//在这里声明变量
//p1和p2都是一种无名结构，
// 里边有X和y  访问一样用.

struct week {定义三
   int x; 
   int y;
}p1,p2;
//常用的一种结构定义声明形式  

对于第一和第三种形式，都声明了结构名week，但是第二种没有声明结构名,只是定义了两个结构变量，
这种叫无名结构

无名结构： 可以定义无名结构体类型的变量。编译器对无名结构体的处理是随机生成一个不重复的变量名。
无名结构的定义方式就是定义无名结构体时必须定义该结构体类型的至少一个变量。

优点：无名结构体的妙用就是可以避免相同类型的结构体的重复定义，
这样可以对每一个具体类型的队列都可以定义一个结构体来管理该队列的头尾指针，
即使定义多个相同具体类型的队列也不会引发重复定义的编译错误。这样定义了两个队列，
其元素类型均为int类型，同时各得到了一个维护队列头尾指针的结构体

缺点：这里定义了一个无名的结构体，同时声明了三个此种类型的变量。
但是，因为没有名字，我们在这句之后，无法内再定义与那三种变量相同类型的变量了。
除非你再容次去定义一个这样的相同的结构体类型。
还有一个重要的原因就是没有办法在其他位置定义我们所需要的结构体变量，
每次需要新定义结构体变量的时候都必须要找到最开始结构体代码书写的位置才能定义新的结构体  
  
所以实际编程中无名结构并不常用

```

注意：

1、结构体本身并不会被作为数据而开辟内存，真正作为数据而在内存中存储的是这种结构体所定义的变量。

2、先声明结构体类型，再定义该类型的变量，声明结构体类型，不分配空间定义结构体类型变量，就要分配内存空间

3、量使用占为少的类型,如,在可能的时候使用short代替int，按数据类型本身占用的位置从大到小排

4、除了可以对成员进行逐一赋值，也可以在定义时整体赋值：p1={struct week}{5,10}; 相当于 p1.x=5,p1.y=10;

p1=p2 表示 p1.x=p2.x ,  p1.y=p2.y; 不过整体赋值仅限于定义结构体变量的时候，在使用过程中只能对成员逐一赋值

5、结构体变量不能相加，相减，也不能相互乘除，但结构体可以相互赋值，也就是说，可以将一个结构体变量赋值给另一个结构体变量。但是前提是这两个结构体变量的结构体类型必须相同

结构体的运算：要访问整个结构，直接用结构变量的名字，对于整个结构，可以做赋值，取地址，也可以传递给函数参数

结构体数值
嵌套的结构体：
```c

struct week{
int x;
int y;
strcut week at;//在结构体又定义了名为at的一个和week同样参数的结构体变量
        //其中可以用.运算符访问  see.at.x see.at.y
}see;
但是其实这样的方式是不建议（非法）的，因为这种声明实际上是一个无限循环，成员at是一个结构体，
at的内部还会有成员是结构体，依次下去，无线循环。在分配内存的时候，由于无限嵌套，
也无法确定这个结构体的长度，所以这种方式是非法的
正确的方式是使用《结构体指针》，因为指针的长度是确定的:

struct week{
int x;
int y;
strcut week *at;//在结构体内定义了一个指向和week一样类型的结构指针
}see;          但是注意用指针访问时要用->运算符   see.at->x
```

结构体相互引用：

一个结构体A中包含一个或多个与结构体B相关的成员, 且结构体B中也包含一个或多个与结构体A相关的成员称为结构体的互引用.

但是要注意： 如果已经定义了两个结构A和B ，在定义结构体A的成员b时，结构体B对A还未可见，故此时编译器会报数据类型B未定义

解决的办法是使用不完整声明：
```c

strcut A;//不完整声明
strcut B;//不完整声明
strcut _A{               strcut _B{
int x;          int x;
int y;                 int y;
struct _B a;        struct _A b;  //在结构B中定义了一个名为b的和A结构一样类型的结构变量
                 //其中可以用点访问 A.a.x   B.b.x
}A；                      }B；
//但是注意这种方式犯了一个和上面第一个嵌套结构的错误，就是结构体A和B都是直接包含了对方，
正确的用法还是使用指针：
strcut _A{               strcut _B{
int x;          int x;
int y;                 int y;
struct _B *a;      struct _A *b;  //在结构B中定义了一个名为b的和A结构一样类型的结构指针
                       //其中指针要用->访问 A.a->x   B.b->x
}A；                                 }B；  
//但是注意这种方式犯了一个和上面第一个嵌套结构的错误，就是结构体A和B都是直接包含了对方，正确的用法还是使用指针：
strcut _A{               strcut _B{
int x;              int x;
int y;                 int y;
struct _B *a;       struct _A *b;  //在结构B中定义了一个名为b的和A结构一样类型的结构指针
                 //其中指针要用->访问 A.a->x   B.b->x
}A；                                }B；
//所以使用互引用要注意：至少有一个结构必须在另一个结构体中以指针的形式被引用。
```

**结构体函数与函数参数**

结构体做函数形参：

整个结构可以作为参数的值传入函数，这时候是在函数内新建一个结构变量，并复制调用者结构的值，也可以返回一个值，这和数组完全不同

用结构体变量作实参时，采取的也是“值传递”方式，将  结构体变量所占的内存单元的内容（结构体变量成员列表）  全部顺序传递给形参，这里形参也得是结构体变量。

```c

#include<stdio.h>
typedef struct _node {

  int n;
  char a[100];

}NODE;

void add(NODE a);//这种形式只是用来做值的传递

int main(void) {
  //以传值方式传递结构需要对整个结构做一份拷贝
  NODE t;
  scanf("%d %d", &t.a[0], &t.n);//输入1  3

  printf("1-%d %d\n",t.a[0],t.n);//输出 1   3

  add(t);
  printf("3-%d %d\n", t.a[0], t.n);//输出1  3

//也就是说在add函数里边做修改根本就影响不了主函数这边的值
}

void add(NODE a) {

  a.a[0] = 100;//在这里能接受到NODE结构里边的成员
  a.n = 666;

  printf("2-%d %d\n", a.a[0], a.n);//输出100   666

}
  ****//解决办法是用指针（也是经常用的方式）：****
#include<stdio.h>
typedef struct _node {

  int n;
  char a[100];

}NODE;

int  add(NODE a);//这种形式只是用来做值的传递

int main(void) {
  //以传值方式传递结构需要对整个结构做一份拷贝
  NODE t;
  scanf("%d %d", &t.a[0], &t.n);//输入1  3

  printf("1-%d %d\n",t.a[0],t.n);//输出 1   3


  add(&t);//这里传进去的是t的地址
  printf("3-%d %d\n", t.a[0], t.n);//输出100  666
//传进去的是地址，所以就可以达到访问同一个变量的操作
}

int  add(NODE *) {//定义一个结构指针

  a.a[0] = 100;//在这里能接受到NODE结构里边的成员
  a.n = 666;

  printf("2-%d %d\n", a.a[0], a.n);//输出100   666
  return a;//这里返回的是指针  所以能达到访问主函数里边调用的值
  //使用指针才可以用返回值
}
//常用的方式

```

另一种做法

结构体做函数：

```c

/*上面的第一个的方案，把一个结构传入了函数，然后在函数中操作，但是没有返回回去
问题在于传入函数的是外面那个结构的克隆体，而不是指针，传入结构和传入数组是不同的，
解决办法是在这个输入函数中，在里边创建一个临时的结构变量，然后把这个结构返回给调用者*/
#include<stdio.h>
typedef struct _node {
  int x;
  int y;
}NODE;
struct _node add();//定义结构类型的函数
int main(void) {

  NODE a;
  a.x = 0;
  a.y = 0;
  printf("1-%d %d\n", a.x, a.y);//   0 0

  a = add();//函数调用   /把n的值又返回到a

  printf("3-%d %d\n", a.x, a.y);//所以在这里的时候值已经被改变
  return 0;
}

struct _node add() {

  NODE n;
  scanf("%d", &n.x);//输入1  3

  scanf("%d", &n.y);

  printf("2-%d %d\n", n.x, n.y);//在这里的时候赋值就成功了

  //return n;//把n的值带回出去
}
//这种方法也能达到“改变"的效果，但是往往开销内存较大，所以一般情况都是使用指针比较方便
```

用结构体变量名作参数，这种传递方式是单向的，如果在执行被调函数期间改变了形参（也是结构体变量）的值，该值不能返回主调函数，这往往造成使用上的不便，因此一般少用这种方法。

和本地变量一样。在函数内部声明的结构只能在函数内部使用，所以通常在函数外部声明一个结构类型的，这样就可以被多个函数所使用

```c

//结构做函数参数例子 （输入今天计算明天）
#include<stdio.h>
#include<stdbool.h>//利用布尔数据类型
struct date {
  int year;
  int month;
  int day;

};

bool If(struct date p);//判断是否是闰年
int number(struct date c);//判断是否是此月最后一天

int main(void) {

  struct date today,tomorrow;
  printf("年-月-日\n");
  scanf("%d %d %d", &today.year, &today.month, &today.day);

  //前面两个判断 是否此月最后一天  是否此年此月最后一天  
  if (today.day==number(today)&&today.month!=12) {//首月1号
    tomorrow.day = 1;
    tomorrow.month =today.month+1;
    tomorrow.year = today.year;
  }
  else if (today.day == number(today) && today.month == 12) {//下一年
    tomorrow.day = 1;
    tomorrow.month = 1;
    tomorrow.year =today.year+1;
  }
  else {
    tomorrow.day =today.day+1;
    tomorrow.month = today.month;
    tomorrow.year = today.year;
  }

  printf("明天是%d-%d-%d\n", tomorrow.year, tomorrow.month, tomorrow.day);
  return 0;
}

int number(struct date c)//这里的形参接收的today结构体数据
{
  int day;
  const int a[12] = { 31,28,31,30,31,30,31,31,30,31,30,31 };//这个月最大的天数

  if (c.month==22&&If(c)) {//查看是否是二月并且是润年
    day = 29;//是润年
  }
  else {

    day = a[c.month - 1];
  }

  return day;
}

bool If(struct date p) {//这里的形参接收的today结构体数据
  //润年的特点，能被4整除，但不能被100整数，能被100整除，但是不能被400整除
  if (p.year % 4 == 0 && p.year / 100 != 0 || p.year % 400 == 0) {
    return true;
  }
  else {
    return false;
  }
}
```

```c

//结构体做函数例子 （计算下一秒）
#include<stdio.h>
struct time {
  int hour;
  int minute;
  int second;
};

struct time times(struct time now);//利用结构做函数返回值，形参也是使用结构体做为传值

int main(void) {
  struct time nows[5] = {
    {11,50,20},{13,25,59},{12,59,59},{23,59,59},{00,00,00},
  };

  int i;
  for (i = 0; i < 5; i++) {
    printf("时间是 %d:%d:%d\n", nows[i].hour, nows[i].minute, nows[i].second);

    nows[i] = times(nows[i]);

    printf("下一秒是 %d:%d:%d\n", nows[i].hour, nows[i].minute, nows[i].second);
  }

  return 0;

}

struct time times(struct time now) {

  now.second++;
  if (now.second == 60) {//60秒
    now.minute++;
    now.second = 0;

    if (now.minute == 60)//60分
    {
      now.hour++;
      now.minute = 0;
      now.second = 0;

      if (now.hour == 24) {//零点
        now.hour=0;
        now.minute = 0;
        now.second = 0;
      }
    }
  }

  return now;//返回类型必须也函数类型一致，换句话说只有结构体类型才能返回结构体类型

}
```

**结构体数组**

结构体数组，是指数组中的每个元素都是一个结构体。在实际应用中，C语言结构体数组常被用来表示一个拥有相同数据结构的群体，比如一个班的学生、一个车间的职工等。结构体可以存储不同的数据类型，将他们互相联系起来。结构体数组可以连续存储多个结构体，和数组作用相似。比如想定义同一个最小外接矩形的四个坐标值，并给予这个矩形一个特征编号。当需要存储多个最小外接矩形的信息时，就需要动态申请一个结构体数组

定义结构体数组的方法很简单，同定义结构体变量是一样的，只不过将变量改成数组。或者说同前面介绍的普通数组的定义是一模一样的：struct student  tp[10]; 这就定义了一个结构体数组，共有 10 个元素，每个元素都是一个结构体变量，都包含所有的结构体成员。

结构体数组的初始化与前面讲的数值型数组的初始化也是一样的，数值型数组初始化的方法和需要注意的问题在结构体数组的初始化中同样适用，因为不管是数值型数组还是结构体数组都是数组。

```c
//例子：  //寻找学生中 学号最大的
# include <stdio.h>
# include <string.h>

struct STU
{
  char name[20];
  int age;
  char sex[20];
  char num[20];

};

void OutputSTU(struct STU stu[]);  //函数声明, 该函数的功能是输出成绩最大的学生信息

int main(void)
{
  int i;
  struct STU stu[5];

  for (i = 0; i < 2; ++i)
  {
    printf("请按照名字、年龄、性别、学号(1-9数字）输入第%d个学生的信息:", i + 1);

    scanf("%s %d %s %s", stu[i].name, &stu[i].age, stu[i].sex, stu[i].num);/*%c前面要加空格, 不然输入时会将空格赋给%c*/
  }

  OutputSTU(stu);

  return 0;
}

void OutputSTU(struct STU stu[])
{
  struct STU stumax = stu[0];//让临时结构stumax保存第一个学生的信息

  int j;
  for (j = 1; j < 2; ++j)//第一个学生依次和后面的学生比较
  {
    if (strcmp(stumax.num, stu[j].num) < 0)  //strcmp函数的使用  s1>s2:1   s1<s2:-1
    {
      stumax = stu[j];//让临时结构保存那个学生的信息
    }
  }

  printf("学生姓名：%s 学生年龄：%d 学生性别：%s 学生分数：%s\n", stumax.name, stumax.age, stumax.sex, stumax.num);

}

```

**结构体指针**

和数组不同，结构变量的名字并不是结构变量的地址，必须使用&运算符  strcut node *tp=&nb;  指针一般用->访问结构体里边的成员

指针变量非常灵活方便，可以指向任一类型的变量    ，若定义指针变量指向结构体类型变量，则可以通过指针来引用结构体类型变量。

```c

#include<stdio.h>
struct node{
int x;
int y;
}my;
int main(void) {
  struct node *p = &my;//定义了一个指针p指向了my的结构体

  p->x = 11;//这是一种访问方式（常用的方式）
  (*p).x = 12;//这是第二种方式，
  printf("%d", p->x);//输出是12

}
以下 2 种形式是等价的：
(*指针变量).成员名。
指针变量->成员名。
其中第 2 种方式很重要，通常都是使用这种方式，另外两种方式用得不多。
后面讲链表的时候用的也都是第 3 种方式。
```

这里说明：结构体和结构体变量是两个不同的概念：结构体是一种数据类型，是一种创建变量的模板，编译器不会为它分配内存空间，就像 int、float、char 这些关键字本身不占用内存一样；结构体变量才包含实实在在的数据，才需要内存来存储。所以用一个结构体去取一个结构体名的地址，这种写法是错误的，也不能将它赋值给其他变量。

```c

#include<stdio.h>
struct point {
  int x;
  int y;
};
struct point *gt(struct point*p);//结构指针函数

void  print(const struct point *p);//结构指针

void out(struct point p);//普通的结构体做函数参数

int main(void) {
  struct point y = { 0,0 };//以point结构定义一个y的结构变量

  //以下三种调用  等价
  //注意gt是一个结构体的指针函数
  gt(&y); //这是一个函数的返回结果函数  //取y结构的地址传入函数
  out(y);
  out(*gt(&y));   // （里边）的都是做为参数  *gt(&y)做为指针返回值  这个函数它的返回用指针表示
  print(gt(&y));  //gt(&y)是一个返回值   这样表示的是利用gt函数的返回值在print函数里边操作

  //*get(&y) = (struct point){ 1,2 };  //这也可以做的
}

struct point* gt(struct point*p) {// *p要的是&y的地址
  
  scanf("%d", &p->x);
  scanf("%d", &p->y);
  printf("a=%d,%d \n", p->x, p->y);//用->来访问指针结构里边的成员

  return p;// 用完指针后 返回指针
}
void out(struct point p) {
  printf("b=%d,%d\n", p.x, p.y);
}

void print(const struct point *p) {//加上const表示不再改动参数
  printf("c=%d,%d\n", p->x, p->y);
}
```

指向结构体数组的指针：

在之前讲数值型数组的时候可以将数组名赋给一个指针变量，从而使该指针变量指向数组的首地址，然后用指针访问数组的元素。结构体数组也是数组，所以同样可以这么做。

我们知道，结构体数组的每一个元素都是一个结构体变量。如果定义一个结构体指针变量并把结构体数组的数组名赋给这个指针变量的话，就意味着将结构体数组的第一个元素，即第一个结构体变量的地址，也即第一个结构变量中的第一个成员的地址赋给了这个指针变量

```c

# include <stdio.h>
struct qt
{
  char name[5];
  int age;
  char sex[5];
  double scroe;
};
int main(void)
{    //定义了一个student的结构数组
  struct qt student[5] = { {"李青", 20, "男", 99}, {"黄欢", 20,  "女", 80}, {"七七", 23, "男", 95} };
  struct qt *p = student;
  int i;
  for (i = 0; i < 5; i++) {

    printf("%s ", p->name);//利用->可访问成员（访问意味着可以读写）
    printf("%d ", p->age);
    printf("%s ", p->sex);
    printf("%f ", p->scroe);
  }
  return 0;
}
当结构体指针变量指向一个结构体变量数组的时候，此时指针变量的值就是结构体数组的首地址,
此时指针变量 p 就指向了结构体数组的第一个元素，即指向 student[0]。我们知道，
当一个指针指向一个数组后，指针就可以通过移动的方式指向数组的其他元素。
这个原则对结构体数组和结构体指针同样适用，所以 p + 1 就指向 student[1] 的首地址；p + 2 就指向 
student[2] 的首地址……所以只要利用 for 循环，指针就能一个个地指向结构体数组元素。

同样需要注意的是，要将一个结构体数组名赋给一个结构体指针变量，那么它们的结构体类型必须相同。
```

**typedef 别名**

typedef是在编程语言中用来为复杂的声明定义简单的别名，新的名字是某种类型的别名，这样做改善了程序的可读性，它与宏定义有些差异。它本身是一种存储类的关键字，与auto、extern、mutable、static、register等关键字不能出现在同一个表达式中。

typedef为C语言的关键字，功能是用来声明一个已有的数据类型的新名字，比如 typedef int last ;  这就使得last成为 int 类型的别名  这样last这个名字就可以代替int出现在变量定义和参数声明的地方了

typedef也有一个特别的长处：它符合范围规则，使用typedef定义的变量类型其作用范围限制在所定义的函数或者文件内（取决于此变量定义的位置），而宏定义则没有这种特性。

```

typedef & 复杂的变量声明
理解复杂声明可用的“右左法则”：
　　从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，
还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：
　　int (*func)(int *p);
　　首 先找到变量名func，外面有一对圆括号，而且左边是一个*号，这说明func是一个指针；
然后跳出这个圆括号，先看右边，又遇到圆括号（只有函数后面才跟形参圆括号），
这说明 (*func)是一个函数，所以func是一个指向这类函数的指针，即函数指针，
这类函数具有int*类型的形参，返回值类型是int，此处就是声明函数。
　　int (*func[5])(int *);
　　func 右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个*，
说明func的元素是指针（注意这里的*不是修饰func，而是修饰 func[5]的，原因是[]运算符优先级比*高，
func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指 针，
它指向的函数具有int*类型的形参，返回值类型为int。

也可以记住2个模式：
type (*)(....)函数指针
type (*)[]数组指针
```

**结构体的内存对齐方式（存储空间）**

结构体内存对齐：一个结构体变量定义完之后，其在内存中的存储并不等于其所包含元素的宽度之和，元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。从结构体存储的首地址开始，每个元素放置到内存中时，它都会认为内存是按照自己的大小来划分的，因此元素放置的位置一定会在自己宽度的整数倍上开始。

内存对齐可以大大提升内存访问速度，是一种用空间换时间的方法。内存不对齐会导致每次读取数据都会读取两次，使得内存读取速度减慢。

cpu把内存当成是一块一块的，块的大小可以是2,4,8,16 个字节，因此CPU在读取内存的时候是一块一块进行读取的，块的大小称为内存读取粒度。

```c
//　内存对齐原则：
//　　　1、第一个成员的首地址为0.
//　　　2、每个成员的首地址是自身大小的整数倍
//　　  3、结构体的总大小，为其成员中所含最大类型的整数倍。

#include<stdio.h>
typedef struct _node {
  //char t;//1
  //int p; //4
  //float y;//8
//char t 要存放的偏移量为0，满足对齐方式，t占用一个字节，
int p要存储在下一个可用的地址的偏移量为1.不是sizeof(int)=4的倍数，
需要补足3个字节才能使偏移量变为4(使其满足对齐方式)，因此系统自动填充3个字节使偏移量增加到4，
int p放到此位置，占用4个字节，下一可用的偏移量为8，满足sizeof(float）=4的对齐，
所以float y直接存放在偏移量为8的位置上，它占用4个字节  总共就是  //1+3+4+4=12

  double a;//8
  char b;//1
  int c;//4
//double a的要存放的偏移量为0，满足对齐方式直接存储，占用8个字节，
char b要存储在下一的可用的地址的偏移量为9，
直接存储，占用字节为1；int c要存储在下一个可用的地址的偏移量为9，
9不满足sizeof（int）=4;所以系统会自动分配3的字节增加到12，12满足对齐方式，
存储下去c占用4个字节。总共就是   //8+1+3+4=16

}NODE;

int main(void) {
  printf("%d ", sizeof(NODE));
}
```

如果结构体内存在长度大于处理器位数的元素，那么就以处理器的倍数为对齐单位；否则，如果结构体内的元素的长度都小于处理器的倍数的时候，便以结构体里面最长的数据元素为对齐单位。

另外  结构体的内存地址就是它第一个成员变量的地址  isa永远都是结构体中的第一个成员变量  所以结构体的地址也就是其isa指针的地址

内存对齐简介
由于内存的读取时间远远小于CPU的存储速度，这里用设定数据结构的对齐系数，即牺牲空间来换取时间的思想来提高CPU的存储效率。

内存对齐”应该是编译器的“管辖范围”。编译器为程序中的每个“数据单元”安排在适当的位置上。但是C语言的一个特点就是太灵活，太强大，它允许你干预“内存对齐”。如果你想了解更加底层的秘密，“内存对齐”对你就不应该再模糊了。这也是一个大小端模式的问题

每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。程序员可以通过预编译命令#pragma pack(n)来改变这一系数，其中的n就是你要指定的“对齐系数”。

规则：

1、数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。

2、结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack 指定的数值和结构(或联合) 最大数据成员长度中，比较小的那个进行对齐。

3、结合1、2可推断：当#pragma pack的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。

#pragmapack(n)  设定变量以n字节为对齐方式：

作用：指定结构体、联合以及类成员

语法：#pragmapack( [show] | [push | pop] [, identifier], n )

1，pack提供数据声明级别的控制，对定义不起作用；

2，调用pack时不指定参数，n将被设成默认值；

n：可选参数；指定packing的数值，以字节为单位；缺省数值是8，合法的数值分别是1、2、4、8、16。

其他参数都是可选的可先不了解

```c

#include<stdio.h>
#pragma pack(2)// 值只能填1 2 4 8 16  这里最好是看结构里边最小的成员 这里是char 所以最好是填1    //但是当#pragma pack指定的值等于或者超过所有数据成员长度的时候，这个指定值的大小将不产生任何效果
typedef struct _A {

  double x;//4
  int y;//4
  char p;//1
  
}NODE;

//8+4+1+1=14按n为2

//8+4+1+3=16按n为4以上或者使用系统自动对齐

#pragma pack(8)//设定为4字节对齐
typedef struct test
{
  char m1;
  double m4;
  int m3;

}NODE2;

//1+1+4+8=14//按n为2
//1+7+8+4=20 不满足8的倍数  加4等于24满足  总：1+7+8+4+4=24


int main(void) {

  printf("%d\n", sizeof(NODE));
  printf("%d", sizeof(NODE2));

}
结构、联合或者类的数据成员，第一个放在偏移为0的地方；以后每个数据成员的对齐，
按照#pragma pack指定的数值和这个数据成员自身长度两个中比较小的那个进行；
也就是说，当#pragma pack指定的值等于或者超过所有数据成员长度的时候，
这个指定值的大小将不产生任何效果；
```

每个成员分别对齐，即每个成员按自己的方式对齐，并最小化长度；规则就是每个成员按其类型的对齐参数（通常是这个类型的大小）和指定对齐参数中较小的一个对齐。

大小端：

```

如：int 11 22 33 44
在存储的时候
大端：11 22 33 44
   0  1   2  3
   低地址----> 高地址

小端：44 33 22 11
   0  1   2  3
   低地址----> 高地址
大小端的差异在于存放顺序不同
常见的操作系统是小端，通讯协议是大端。
```

```c

//结构体例子：使用尾插法创建链表
#include<stdio.h>//单链表的创建

typedef struct _node {

  int nb;//数值
  struct _node *nxte;//定义一个指向下一个的节点的指针

}NODE;

typedef struct _link{//利用这个结构体 封装 首尾节点

  NODE *head;
  NODE *qt;

}link;

void  add(link *phead, link *qt, int n);//定义函数将 首尾指针传入

int main(void) {

  link head, q;//定义一个结构，连指针都不是的
  head.head = q.qt = NULL;//初始化

  int n;

  for (scanf("%d", &n); n != -1; scanf("%d", &n)) {
    add(&head, &q, n);//将地址 值传入
  }

  NODE *t;
  t = head.head;//利用临时结构将链表输出
  for (; t; t = t->nxte) {
    printf("%d ", t->nb);
  }

  return 0;
}

//尾插法
void  add(link *phead, link *qt, int n) {

  NODE *p = (NODE*)malloc(sizeof(NODE));//为新结点开辟空间
  p->nb = n;
  p->nxte = NULL;

  if (phead->head == NULL) {//判断首结点是否为空
    phead->head = p;//是空的就让首结点等于新结点
  }
  else {//不为空时，让尾结点依次跑到后面去
    qt->qt->nxte = p;
  }

  qt->qt = p;
}
```

**union 共用体（联合体）**

在进行某些算法的C语言编程的时候，需要使几种不同类型的变量存放到同一段内存单元中。也就是使用覆盖技术，几个变量互相覆盖。这种几个不同的变量共同占用一段内存的结构，在C语言中 以关键字union声明的一种数据结构，这种被称作“共用体”类型结构，也叫联合体。

“联合”与“结构”有一些相似之处。但两者有本质上的不同。在结构中各成员有各自的内存空间，一个结构体变量的总长度大于等于各成员长度之和。而在“联合”中，各成员共享一段内存空间，一个联合变量的长度等于各成员中最长的长度。注意这里所谓的共享不是指把多个成员同时装入一个联合变量内，而是指该联合变量可被赋予任一成员值，但每次只能赋一种值，赋入新值则冲去旧值，共用体变量中起作用的成员是最后一次存放的成员，在存入一个新成员后，原有成员就失去作用，共用体变量的地址和它的各成员的地址都是同一地址

一个联合类型必须经过定义之后，才能把变量说明为该联合类型:
```

联合的定义:
定义一个联合类型的一般形式为：
union [name](联合名)   name是可选的
{
成员表
};
成员表中含有若干成员，成员的一般形式为： 类型说明符 成员名
成员名的命名应符合标识符的规定。

union Data
{
   int i;
   double f;
   char  str[20];
} data;


现在 Data所有的成员共享一个空间，同一时间只有一个成员是的值有效的，Data 类型的变量可以存储一个整数、
一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。
您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。
共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，
Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。
```

注意：1、不能把共用体变量作为函数参数，也不能是函数带回共用体变量，但可以使专用指向共用体变量的指针

2、所有成员占用同一段内存，修改一制个成员会影响其余所有成员。

共用体的访问：

共用体访问成员的值时一般使用.运算符，指针时用->运算符（和结构体是一样的）

```c

typedef union _node {
  int a;
  double b;
  char c;
  union _node *p;

}NODE;

int main(void) {

  NODE a;//定义变量
  NODE t;
  a.b;//用.访问
  t.p->a;//指针用->访问



}
联合的使用规则几乎和结构体strtct的规则用法一样，只不过是内部表示的不同。

补充：
还有一个是无名联合体，它是和无名结构体的工作原理是相同的

```

```c
#include<stdio.h>//简单的例子
#include<string.h>

typedef union _node{
  int a;
  double b;
  char c[20];

}NODE;

int main(void) {

  NODE a;//这里只定义一个变量

  a.a = 666;
  printf("%d\n", a.a);

  a.b = 9.99;
  printf("%f\n", a.b);

  strcpy(a.c, "hello world!");
  printf("%s\n", a.c);

  //我们看到，三个都被完整的输出了，因为在同一时刻，只有一个成员是有效的

}

输出：
666
9.990000
hellow world!
```

共用体的作用：

1、节省内存，有两个很长的数据结构，不会同时使用，比如一个表示老师，一个表示学生，如果要统计教师和学生的情况用结构体的话就有点浪费了！用结构体的话，只占用最长的那个数据结构所占用的空间，就足够了！

2、实现不同类型数据之间的类型转换，遇到各种类型的数据共用存储空间，很方便的实现了不同数据类型之间的转换，不需要显示的强制类型转换。

其他：

1、确定CPU的模式：大端、小端模式确定

大小端不同，则存储的方式也存在差别，比如int需要4个字节，而char只需要1个字节，根据1个字节所在的具体位置即可判定CPU的模式

2、寄存器的定义，实现整体的访问和单项的访问

```c
//共用体综合例子：根据输入的数据类型输出需要的相应的数据
#include<stdio.h>
#include<string.h>//数据类型输出   5*4  m n     n的第几个x 

union node {
  int a;
  double b;
  char c[30];

}add[10000];

char p[10000][30]; //保存的字符串数组

int main(void) {
  int n, m;
  scanf("%d %d", &n, &m);
  int x;
  double y;
  char t[50];
  int i, j;

  for (i = 0; i < n; i++) {//输入
    scanf("%s", &p[i]);//作为字符串数组，需要取地址

    if (strcmp("INT", p[i]) == 0) {//整形
      scanf("%d", &x);
      add[i].a = x;
    }
    else if(strcmp("DOUBLE",p[i])==0){//浮点
      scanf("%lf", &y);
      add[i].b = y;
    }
    else if (strcmp("STRCING", p[i]) == 0) {//字符串
      scanf("%s", t);
      strcpy(add[i].c, t);
    }

  }

  for (i = 0; i < m; i++) {//输出
    scanf("%d", &j);

    if (strcmp("INT", p[j]) == 0) {
      printf("%d\n", add[j].a);
    }
    else if (strcmp("DOUBLE", p[j]) == 0)
    {
      printf("%f\n", add[j].b);
    }else if(strcmp("STRING",p[j])==0)
    {
      printf("%s\n", add[j].c);

    }

  }

  return 0;

}

//输入：
/*
5 4
INT 456
DOUBLE 123.56
DOUBLE 0.476
STRING welcomeToC
STRING LemonTree
0
1
2
4
*/

//输出：
/*
456
123.56
0.48
LemonTree

*/
```

#### Union封装网络字节流

**union 在数据传输中的应用**

背景：现在有两个小车需要进行通信，分别是小车 A 和小车 B ，有些时候，小车 A 需要向小车 B 发送它当前的速度，有些时候，小车 A 需要向小车 B 发送它当前的位置，而有些时候小车 A 需要向小车 B 发送它当前的状态。

分析：在上面的背景当中，我们得知发送的消息的时候并不是同时要发送速度，状态，位置，而是这三个参数分开来的，并不是同时需要，那这个时候，我们就可以采用 union 的特性来构造一个数据结构，这样做的好处是能够缩减变量占用的内存，比如说我们不采用 union 来构造的话，通常我们会采用结构体的方式，比如这样：
```c
struct
 buffer

{

    
uint8_t
 power
;
   
/*当前电池容量*/

    
uint8_t
 op_mode
;
 
/*操作模式*/

    
uint8_t
 temp
;
    
/*当前的温度*/

    
uint16_t
 x_pos
;

    
uint16_t
 y_pos
;

    
uint16_t
 vel
;
   
/*小车当前的速度*/

}
my_buff
;
```







#### C语言进行json的序列化和反序列
##### 前言
json是目前最为流行的文本数据传输格式，特别是在网络通信上广泛应用，随着物联网的兴起，在嵌入式设备上，也需要开始使用json进行数据传输，那么，如何快速简洁地用C语言进行json的序列化和反序列化呢？

当前，应用最广泛的C语言json解析库当属cJSON，但是，使用cJSON读json进行序列化和反序列化，需要根据key一个一个进行处理，会导致代码冗余，逻辑性不强，哪有没有更好的方法呢？

思路在Android平台，一般会使用gson等工具解析json，这些工具将json直接映射成对象，在C语言上使用对象的概念，我们需要借助结构体，然而，最大的问题在于，C语言没有高级语言具有的反射机制，直接从json映射到结构体对象几乎是不可能的。
怎么解决呢，既然C语言没有反射机制，那么我们可以自己定义一套类似于反射的机制，这里我将其称之为结构体数据模型，在数据模型中，我们需要准确地描述结构体的特征，包括结构体各成员的名称，类型，在结构体中的偏移。
有了这些，我们可以在解析josn的时候，将解析得到的数据直接写入到对应的内存里面去，或者是在序列化的时候，直接从对应的内存中读取数据，进行处理。

实现CSON正是采用上面说到的思路，使用数据模型对结构体进行描述，然后基于cJSON，根据数据模型进行解析，将解析得到的数据直接写入到对应的内存区域，从而实现从json到结构体对象的映射。
CSON最基本的数据模型定义如下：
```c
typedef struct cson_model
{
    CsonType type;                      /**< 数据类型 */
    char *key;                          /**< 元素键值 */
    short offset;                       /**< 元素偏移 */
} CsonModel;
```
通过type描述结构体成员的数据类型，key描述该成员在json中对应的字段，offset描述该结构体成员在结构体中的偏移，CSON在解析json的时候，根据type调用相应的cJSON API并传递key作为参数，得到解析出的数据，然后根据offset将数据写入到对应的内存空间。
比如说这样一个结构体：
```c
struct project
{
    int id;
    char *name;
}
```
该结构体包含两个成员，对于成员id，我们使用数据模型对其进行描述
```c
{.type=CSON_TYPE_CHAR, key="id", offset=0}
```

对于结构体的每个成员，都进行数据模型的定义，就可以得到一个完整的结构体数据模型，CSON会根据这个模型，进行解析。
因为是通过直接写内存的方式，所以在写不同类型的量到内存中时，会多次用到强制转型，导致CSON中赋值的代码都类似于：
```c
*(int *)((int)obj + model[i].offset) = (int)csonDecodeNumber(json, model[i].key);
```

当然，上面说到的数据模型，只适用于基本数据类型的数据，对于子结构体，链表，数组等，需要对数据模型的定义进行扩充，有兴趣的朋友可以直接阅读CSON源码。
CSON使用实例

声明结构体：
/** 项目结构体 */
struct project
{
    int id;
    char *name;
};

/** 仓库结构体 */
struct hub
{
    int id;
    char *user;
    struct project *cson;
};

定义数据模型：
对每一个需要使用cson的结构体，都需要定义相对应的数据模型

```c
/** 项目结构体数据模型 */
CsonModel projectModel[] =
{
    CSON_MODEL_OBJ(struct project),
    CSON_MODEL_INT(struct project, id),
    CSON_MODEL_STRING(struct project, name),
};

/** 仓库结构体数据模型 */
CsonModel hubModel[] =
{
    CSON_MODEL_OBJ(struct hub),
    CSON_MODEL_INT(struct hub, id),
    CSON_MODEL_STRING(struct hub, user),
    CSON_MODEL_STRUCT(struct hub, cson, projectModel, sizeof(projectModel)/sizeof(CsonModel))
};
```

使用CSON解析：
只需要定义好数据模型，就可以使用CSON读json进行序列化和反序列化

```c
void csonDemo(void)
{
    char *jsonDemo = "{\"id\": 1, \"user\": \"Letter\", \"cson\": {\"id\": 2, \"name\": \"cson\"}}";

    /** 解析json */
    struct hub *pHub = csonDecode(jsonDemo, hubModel, sizeof(hubModel)/sizeof(CsonModel));
    printf("hub: id: %d, user: %s, project id: %d, project name: %s\r\n",
        pHub->id, pHub->user, pHub->cson->id, pHub->cson->name);

    /** 序列化对象 */
    char *formatJson = csonEncodeFormatted(pHub, hubModel, sizeof(hubModel)/sizeof(CsonModel));
    printf("format json: %s\r\n", formatJson);

    /** 释放结构体对象 */
    csonFree(pHub, hubModel, sizeof(hubModel)/sizeof(CsonModel));

    /** 释放序列化生成的json字符串 */
    csonFreeJson(formatJson);
}
```

运行结果：
```c
hub: id: 1, user: Letter, project id: 2, project name: cson
format json: {
        "id":   1,
        "user": "Letter",
        "cson": {
                "id":   2,
                "name": "cson"
        }
}
```

可以看到，无论是解析json，还是序列化结构体到json，在使用CSON的情况下，都只需要一行代码就可以解决，同样的操作，在使用原生cJSON的情况下，你可能需要多次判断，解析元素。
CSON地址:https://github.com/NevermindZZT/cson。


### 浅谈嵌入式MCU软件开发之中断优先级与中断嵌套；

### 浅谈嵌入式MCU软件开发之应用工程的堆与栈；

### 浅谈嵌入式MCU软件开发之代码风格与代码优化；

### 浅谈嵌入式MCU硬件设计之电源与复位电路设计；

### 浅谈嵌入式MCU软件开发之startup过程详解(从复位向量到main函数之前的准备工作)；

### 参考文献
1、关于语言特性

- Stephen Prata 著 云巅工作室 译 《C Primer Plus（第五版）中文版》
- Andrew Koenig 著 高巍 译 《C陷阱与缺陷》
- Peter Van Der Linden 著 徐波 译 《C专家编程》
- 陈正冲 编著 《C语言深度解剖》
  
2、关于编译器

- 杜春雷 编著 《ARM体系结构与编程》
- Keil MDK 编译器帮助手册

3、关于防御性编程

- MISRA-C-:2004 Guidelines for the use of the C language in criticalsystems
- Robert C.Seacord 著 徐波 译 《C安全编码标准》

4、关于编程思想

- Pete Goodliffe 著 韩江、陈玉 译 《编程匠艺---编写卓越的代码》
- Susan Lammers 著 李琳骁、吴咏炜、张菁《编程大师访谈录》
## ARM体系架构学习

## 车规级和工业级MCU外设资源汇总学习

### 工业级

#### 工业MCU专栏

#### 工业总线通信
##### 片上外设使用tips之MCU的心跳之源--时钟(内部IRC与外部时钟)

##### 片上外设使用tips之TIM定时器使用；

##### 片上外设使用tips之GPIO使用；

##### 片上外设使用tips之COP看门狗使用；

##### 片上外设使用tips之SAR ADC使用；

##### 片上外设使用tips之MSCAN使用；

##### 片上外设使用tips之UART/SCI使用；

##### 片上外设使用tips之I2C使用；

##### 片上外设使用tips之SPI使用；

##### 片上外设使用tips之FlexCAN使用；

##### 片上外设使用tips之DCU使用；

##### 片上外设使用tips之eMIOS使用；

##### 片上外设使用tips之Flash加密(security)与保护(protection；

##### 片上外设使用tips之片上memory ECC工作机制与使用；

### 车规级

#### 汽车电子总线技术科普之LIN总线；

#### 汽车电子总线技术科普之CAN总线；

#### 汽车电子总线技术科普之FlexRay总线；

#### 汽车电子总线技术科普之Ethernet总线；


## TinyML MCU学习

## 嵌入式微控制器设计（SoC和FPGA）

## 嵌入式DSP设计

## 可重构计算（FPGA）

## 集成电路测试指南


