---
layout: post
title: 嵌入式linux启动流程笔记
date: 2022-08-11
author: lau
tags: [Linux, Note]
comments: true
toc: true
pinned: false
---

嵌入式linux启动流程笔记。

<!-- more -->

## 嵌入式Linux概述

大致流程如下图：
![](https://s1.328888.xyz/2022/08/11/6j2hE.png)

**Bootloader**：硬件上电后跳到一个固定位置执行相应代码，初始化相应设备，加载内核代码到内存，跳到内核代码起始位置执行；

**kernel**：内核自解压，初始化静态编译进内核的驱动模块，挂载根文件系统，直接执行第一个用户空间程序；

**第一个用户空间程序**：配置用户环境和执行服务进程。

## 嵌入式Linux系统构成

![](https://img-blog.csdn.net/20130911140900046)

上图是一个嵌入式Linux系统的典型结构，划分成了4个区：

- 1、Bootloader区存放的是Bootloader，它负责嵌入式系统最初的硬件初始化、驱动和内核加载。

- 2、参数区不是必须的，通常存放了一些系统参数，并且通常这个区是没有文件系统，参数以原始数据的格式来存放。

- 3、内核镜像区存放的Linux内核压缩镜像，它被解压后运行于内存，作为嵌入式设备的Linux操作系统。

- 4、文件系统区存放经过压缩的文件系统，它会被Linux内核解压并挂载，并作为各种应用程序、文件的主要载体。

这4个区都以二进制数据的形式存放于嵌入式设备的Flash芯片上。

## 嵌入式Linux系统启动过程

嵌入式设备从上电那一刻到应用程序正常运行，其间经历过一系列漫长的过程，下面对主要的步骤进行阐述：

1、嵌入式设备上电后，CPU开始运行，通常CPU会从某一个固定的物理地址开始运行，这个物理地址一般是Flash芯片的起始物理地址。Flash芯片的最初一段通常存放的是Bootloader，于是CPU就会开始运行Bootloader的代码。

2、我们知道CPU可以读写Flash上的数据，但是不能直接执行Flash上的指令，CPU通常只能执行内存中的指令，那么CPU刚开始运行时怎样去执行Flash上的指令呢？这里分两种情况，Flash芯片主要分为两种，一种是Nor Flash，另一种是Nand Flash，Nor Flash具有可以直接在Flash芯片上执行指令的特点。如果嵌入式设备采用的是Nor Flash，那就比较简单了，CPU可以直接运行在Nor Flash上的指令。如果采用的是Nand Flash呢，怎么办？目前主要有两种方法，一种方法是Flash控制器能够把Nand Flash的前4k数据搬到4k的内部RAM中，并设置CPU从这个内部RAM的起始地址开始启动执行。另一种方法是Flash控制器能够把Nand Flash的前4k数据的地址映射到系统总线的某个地址上，并设定CPU从这个地址开始启动执行。这两种方法都是硬件来完成的。

3、Bootloader分为两个部分，第一部分是汇编代码且不做压缩，第二部分是C代码且有压缩的。Bootloader开始执行时，第一部分汇编代码先负责初始化CPU、PLL、DDR、Cache等硬件，让CPU和内存能够稳定运行，然后解压第二部分的Image，并拷贝到到内存执行。第二部分C代码完成串口、flash、网口等驱动的加载，并构建一个shell环境来接受用户输入。注意，在整个Bootloader运行其间CPU的MMU是没有被初始化的，所有的地址访问都是采用物理地址直接访问的。

4、在完成Bootloader初始化后，根据代码中设定的内核区物理地址，Bootloader会把内核区压缩后的Linux镜像拷贝到内存中并解压。同时准备好内核的启动参数，如：console=ttyS0,115200 root=31:2 mtdparts=ar7100-nor0:196608(boot),835236(kernel),-(rootfs)，这里主要是把Bootloader里设置的MTD分区信息传递给内核，还有需要加载的根文件系统。最后跳转到内核入口开始运行。

5、Linux内核代码开始执行，会先进行内核各个子系统初始化，并完成对MMU的初始化。MMU是CPU中的一个单元，它跟操作系统一起配合完成从虚拟地址到物理地址的转换。如果CPU带有MMU单元，则CPU执行单元发出的内存地址将被MMU截获，从CPU到MMU的地址称为虚拟地址，而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，这个地址称为物理地址。在这个过程中Linux内核会维护页表结构，它保存着内核和进程的虚拟地址到物理地址的映射，而MMU则通过Linux内核页表去完成地址翻译和保护工作。

6、接下来Linux内核会挂载根文件系统，要挂载的根文件系统是通过内核启动参数来获取的。这里有一个问题，根文件系统通常表示为一个Linux文件系统下的某个MTD设备，但在加载根文件系统前Linux还没有一个文件系统，那它怎样通过访问文件系统中的MTD设备来加载根文件系统呢？事实上，根文件系统的安装分为两个阶段，首先Linux内核会安装一个特殊的RootFS文件系统，该文件系统仅提供一个作为初始安装点的空目录，然后Linux内核再在空目录上安装一个真正的根目录。Linux内核对Flash的访问都是通过MTD子系统来进行的，它抽象了对于各种Flash设备的访问，提供统一的接口。

7、Linux内核继续初始化各种类型的驱动程序，完成之后会启动第一个应用程序，它的进程ID为1。这个应用程序可以由内核启动参数传入，如果没有则会默认执行/sbin/init。init进程会读取配置文件/etc/inittab，根据配置文件的内容它会完成两个工作，执行rcS和启动Shell。至此，Linux系统已经启动完成，给用户提供了一个Shell的交互环境，后续的行为就取决于用户的输入或者系统特定应用的加载。

## 为什么需要bootloader

受单片机和ARM7等小型CPU设备编程思维的影响，开始对嵌入式linux和PC中存在bootloader/BIOS的意义有了疑问

bootloader到底有没有必要存在呢？答案是：大部分情况下是有必要的。

首先，bootloader的作用是在硬件上电后运行的第一段软件代码，也叫引导加载程序，是在操作系统内核运行之前运行的一小段程序，这小段程序的作用一般是初始化硬件设备，比如内存啊，堆栈等等，从而将系统的硬件环境编程一种合适的状态，然后再引导加载操作系统，如linux或windows。

乍一看，其实挺有用，但这是一定必须的吗？显然不是，因为完全可以上电直接运行操作系统，当然这个操作系统的开头必须要包含上述bootloader的功能。这一点在单片机和ARM7中使用keil编程环境能理解。

但是，问题来了，如果我们想升级操作系统呢？我们想升级应用程序呢？这一点对于windows或者linux都是很常见的，如果没有bootloader，那么我们必须要找到烧写电脑或者CPU的烧写工具，事实上，这对于生产商来讲，都不是一件容易的事情。但是有bootloaer就很方便了，我们只需要将升级后的操作系统放到“硬盘”或nandflash中的某个位置，然后断电重启一下，bootloader就能在引导系统的同时，完成了对操作系统的升级。这样是不是很方便了。

后续，目前有一些手机厂家对bootloader“上锁”，这个就相当于是给bootloader引导上了把锁，升级的操作系统如果是自家的，自然是有“解锁”的钥匙的，但是是其他家的，那就不行了。

假如你做的产品卖给用户，当你发现该产品存在致命的问题，你是不是要去对程序进行更改，由于销售路径遍布各地，你不可能拿着一堆东西（电脑、下载器等）去找人家升级程序吧？ 再说产品都是包装好的，预留的接口都是常用的接口，如USB、232/485 、SD卡等等，难道你还要去拆卸产品？   有了Bootloader就方便很多了，例如将升级文件拷贝在SD卡里面，或者通过nfs tftp，简单按下按钮、点一下屏幕就可以升级，别人操作起来也方便。

上述论述，如果需要升级系统，bootloader将功能并入linux，那么需要重新编译整个image，sd卡没什么问题，都是将image拷贝进去，比较方便（bootloader和linux分开，就是拷贝linux image，否则就是拷贝整个image）

对于nand启动（bootloader和linux分开，可以通过tftp或nfs将linux image下载到内存，再通过uboot烧写到nand，有网口就可以，否则就是要通过工具烧写nand了），在这一点上是有差别的。

以上是一个原因，还有一个原因是：

内核启动需要必要的启动参数：(1)内核是不能开机自动完全从零开始启动的，内核启动需要别人帮忙。uboot要帮助内核实现重定位（从SD卡到DDR ）uboot还要给内核提供启动参数。(2)启动内核第一步:加载内核到DDR中

uboot要启动内核，分为2个步骤：第一步是将内核镜像从启动介质中加载到DDR中，第二步是去DDR中启动内核镜像。（内核代码根本就没考虑重定位，因为内核知道有bootloader帮忙把自己加载到DDR中链接地址处，内核就直接从链接地址处运行的）。

## 代码可在NOR Flash上运行的解释

经常听到程序代码可在NOR Flash上运行，而不能在NAND Flash上运行的说法，关于这个说法容易给人造成误解，因为CPU执行代码分为取指、译码、执行三个步骤，所以真正运行代码的还是CPU，对于NOR Flash可以直接运行代码的说法，指的是CPU可以直接通过地址总线从NOR Flash上完成取指的操作。更深入的理解这个概念，我们先了解以下知识点。

1.FLASH存储器

FLASH 存储器又称为闪存，它也是可重复擦写的存储器。根据存储单元电路的不同，FLASH存储器又分为 NOR FLASH 和 NAND FLASH，其二者特性对比如表所示：

NOR与NAND特性的差别，主要是由于其内部“地址/数据线”是否分开导致的。由于 NOR的地址线和数据线分开，它可以按“字节”读写数据，符合 CPU 的指令译码执行要求，所以假如 NOR上存储了代码指令， CPU 给 NOR一个地址， NOR 就能向
CPU 返回一个数据让 CPU 执行，中间不需要额外的处理操作。

而由于 NAND 的数据和地址线共用，只能按“块”来读写数据，假如 NAND 上存储了代码指令， CPU 给 NAND 地址后，它无法直接返回该地址的数据，所以不符合指令译码要求。 即不支持立即执行的特性(eXecute In Place)，若代码存储在NAND上，可以先把它加载到RAM存储器上，再由CPU执行。

注：由于Flash擦写通常是整块擦写，块内有一位失效整个块就会失效，这被称为坏块，而Nor 和 Nand Flash都有可能存在坏块，所以Flash存储器需要“探测/错误更正（EDC/ECC）”算法来确保数据的正确性。

2.XIP（ eXecute In Place）

XIP，executed in place，本地执行。操作系统采用这种系统，可以不用将内核或执行代码拷贝到内存，而直接在代码的存储空间（Nor Flash）直接运行。采用这样的技术既可以节省可用内存又可以减少加载的时间。由于Nand Flash的特性不支持XIP，所以不能在 Nand Flash中运行代码。

代码执行流程如上图所示，其中NAND Flash执行代码时，需要先将代码加载到RAM中，CPU再从RAM中取指、译码、运行。而NOR Flash支持XIP，CPU可以直接通过总线从NOR Flash中取指，不需要将代码加载到RAM中运行。

## 福利-安卓源码学习路径

我干了3年Android sdk开发，觉得到了瓶劲没法更进一步，于是花了一年多点时间，大概摸到点门径。根据前辈的经验，Android底层完全入门需要两年。 　　

先说下我的入门过程： 　　

第零步，下载源码，我下的4.2的，框架层源码10G，内核2G多，ctags给框架层建的标签文件都有600M，当时让我有点震撼，用的vim+ctags+cscope来阅读，还算不错，架构挺清晰的。 　　

第一步，我找到了一本好书《Android的设计与实现 第一卷》它讲了Android框架层的启动，初始化，服务框架初始化，Binder，消息循环，PackageManagerService，ActivityManagerService。据作者说后面会出讲UI子系统的第二卷，拭目以待。其实这本书看了几十页我就发现需要第二步的知识，否则看不下去，于是跳去第二步。 　　

第二步，学习Linux系统编程，在看《Android的设计与实现》的时候我发现，框架层的Native部分，全是Linux编程。为了掌握这部分知识，我花了4个月学习了《Linux系统编程手册》（TLPI）这本1000多页的书，我以前是搞WIndows文件系统这块的，所以C语言还比较熟，TLPI的习题很有意思，量也比较大，坚持下来还是收获很多。 　　

第三步，花了4个月学习了一些Linux内核的知识，看了LKD，PLKA看了一半多。越学越没底，觉得不懂得越来越多，不过这个也正常，只有靠慢慢磨，估计以后要不断的磨这块。 　　

第四步，回头看Android源码，这次一口气看完了《Android的设计与实现 第一卷》，终于对框架层有了谱。同时真的数次把我看晕，前面看Linux内核源码都没这么晕，不断在Java层和Native层之间跳有点磨脑浆。其中我又觉得Java的基础没有打太牢，回去补了一个月的《Core Java》第八版。但是这书没有涉及UI子系统，于是又看了《Android内核剖析》 　　

第五步，《Android内核剖析》（这本书实际上是讲框架层的，作者也是个搞嵌入式的，所以他在写框架层的时候文笔不太好，很罗嗦，不过还是有很多看点，到他后来写做ROM，玩开发板时估计是说到了他的本行，一下子遛起来了看得出还是挺有水平的，这本书知识有点旧毕竟讲的是2.3很多代码已经过时，但是作者很多点子很有参考价值）这本书讲UI子系统和按键/触摸消息处理系统还是很有分量的，尤其13章View绘制那里，结合源码研究很有收获。而后面他讲编译框架和ROM相关的东西都是挺宝贵的资料。 　　

第六步，为了再补一下其他诸如电源管理模块等子系统的知识看了，《深入理解android》系列，个人认为这个系列看起来有点不太舒服，不过作为补充印证还是比较有价值。 　　

第七步，《Android系统源代码情景分析》，罗升阳的源码分析大作，比《Android的设计与实现》分析得更细致，但缺点是涉及到模块比较少，选用的源码也比《Android的设计与实现》更旧一点。看完书后需要去研究作者的博客，东西挺多的，一定让你满意。 　　

第八步，买块开发板自己玩。这步我还没走到，原因是我觉得我还差点准备知识。可能要再几个月，到时准备入块6410或者树莓派。 　　

最后，由于我11年以前都是搞Windows这块的，所以对Linux知识不是很了解，不得已看了这么些书，如果是一直做Linux的人，很多步骤估计可以省掉了。直接上源码才是正道。 　　

我本身做着移动GIS开发的工作，学框架层全是因为兴趣，但招聘平台Android框架层开发人员还是蛮有竞争力的有不少定制ROM，智能电视的工作都处于人才难求状态，毕竟有一定的门槛，现在各种ios培训，让奔着钱干开发的人纷纷涌入，而ios只能干sdk开发的缺点就暴露出来了，一堆新手老手，菜鸟大牛全挤在SDK开发这块，我觉得不太妙。 反观Android这边，虽然入门菜鸟没有搞ios来钱，但是可持续性很好，从sdk-》框架》驱动》内核这样干下去。干着干着发现自己渐渐变成了Linux开发者/嵌入式开发者的人也不少，新人，老手，菜鸟大牛各居其位，层次性很好。
